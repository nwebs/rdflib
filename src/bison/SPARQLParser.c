/*
 * DO NOT EDIT THIS FILE!
 *
 * Parser generated by BisonGen on Sat May 20 08:02:14 2006.
 */

#include "Python.h"
#include "structmember.h"

#define PROJECT_NAME "rdflib.sparql.bison"
#define PARSER_NAME "SPARQLParser"
#define MODULE_INITFUNC initSPARQLParserc

/* modules required for action routines */
static PyObject *IRIRef;
static PyObject *Bindings;
static PyObject *Query;
static PyObject *QName;
static PyObject *GraphPattern;
static PyObject *FunctionLibrary;
static PyObject *Operators;
static PyObject *Triples;
static PyObject *Resource;
static PyObject *Filter;
static PyObject *Util;
static PyObject *Expression;
static PyObject *BooleanOperators;
static PyObject *SolutionModifier;
static PyObject *rdflib;
static PyObject *RDF;

/* token definitions */
#define WHITESPACE 257
#define UNION 258
#define QNAME 259
#define QNAME_NS 260
#define Q_IRI_CONTENT 261
#define BLANK_NODE_LABEL 262
#define VARNAME 263
#define PREFIX 264
#define ASTERISK 265
#define DOT 266
#define QUESTION_MARK 267
#define DOLLAR 268
#define BASE 269
#define SELECT 270
#define DISTINCT 271
#define FROM 272
#define NAMED 273
#define OPTIONAL 274
#define FILTER 275
#define GRAPH 276
#define WHERE 277
#define ORDER 278
#define BY 279
#define ASC 280
#define DESC 281
#define LIMIT 282
#define OFFSET 283
#define STR 284
#define LANG 285
#define LANGMATCHES 286
#define DATATYPE 287
#define isIRI 288
#define isURI 289
#define isLITERAL 290
#define isBLANK 291
#define BOUND 292
#define REGEX 293
#define A 294
#define TRUE 295
#define FALSE 296
#define DOUBLE_AMPERSAND 297
#define DOUBLE_PIPE 298
#define BANG 299
#define DOUBLE_HAT 300
#define COMMA 301
#define FORWARDSLASH 302
#define LEFT_PAREN 303
#define RIGHT_PAREN 304
#define LEFT_SQUARE 305
#define RIGHT_SQUARE 306
#define SEMICOLON 307
#define INTEGER 308
#define DECIMAL 309
#define DOUBLE 310
#define STRING_LITERAL_DELIMETER_1 311
#define STRING_LITERAL_DELIMETER_2 312
#define STRING_LITERAL_DELIMETER_3 313
#define STRING_LITERAL_DELIMETER_4 314
#define STRING_LITERAL1 315
#define STRING_LITERAL2 316
#define STRING_LITERAL_LONG1 317
#define STRING_LITERAL_LONG2 318
#define NIL 319
#define ANON 320
#define LANGTAG 321
#define LEFT_CURLY 322
#define RIGHT_CURLY 323
#define PLUS 324
#define MINUS 325
#define EQUALITY_OP 326
#define NOT_EQUAL 327
#define LESS_THAN 328
#define GREATER_THAN 329
#define LESS_THAN_EQUAL 330
#define GREATER_THAN_EQUAL 331

/* vector mapping lexer token numbers into internal token numbers */
static const int token_translations[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
2, 2, 2, 2, 2, 1, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 
18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 
36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 
54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 
72, 73, 74, 75, 76, 77};

#define YYTRANSLATE(x) ((unsigned)(x) <= 331 ? token_translations[x] : 137)

/* vector of items of all rules. */
static const int rhs_tokens[] = {0, 80, 79, 0, 79, 0, 85, 0, 84, 81, 0, 81, 
0, 82, 0, 0, 83, 0, 82, 83, 0, 10, 6, 74, 7, 75, 0, 15, 74, 7, 75, 0, 16, 
86, 92, 93, 0, 16, 86, 90, 92, 93, 0, 16, 17, 86, 92, 93, 0, 16, 17, 86, 
90, 92, 93, 0, 87, 0, 11, 0, 130, 0, 87, 130, 0, 74, 7, 75, 0, 89, 0, 5, 
0, 6, 0, 91, 0, 90, 91, 0, 18, 88, 0, 18, 19, 88, 0, 23, 99, 0, 99, 0, 
0, 94, 0, 94, 97, 0, 94, 97, 98, 0, 97, 98, 0, 94, 98, 0, 98, 0, 97, 0, 
24, 25, 95, 0, 96, 0, 95, 96, 0, 26, 49, 103, 50, 0, 27, 49, 103, 50, 0, 
115, 0, 49, 103, 50, 0, 130, 0, 28, 132, 0, 29, 132, 0, 68, 100, 69, 0, 
118, 0, 118, 101, 100, 0, 118, 101, 12, 100, 0, 20, 99, 0, 99, 102, 0, 
4, 99, 0, 102, 4, 99, 0, 105, 0, 105, 104, 0, 44, 105, 0, 104, 44, 105, 
0, 107, 106, 0, 107, 0, 43, 107, 0, 106, 43, 107, 0, 108, 0, 108, 72, 108, 
0, 108, 73, 108, 0, 108, 74, 108, 0, 108, 75, 108, 0, 108, 76, 108, 0, 
108, 77, 108, 0, 110, 0, 110, 109, 0, 70, 110, 0, 71, 110, 0, 109, 71, 
110, 0, 109, 70, 110, 0, 112, 0, 112, 111, 0, 11, 112, 0, 48, 112, 0, 111, 
11, 112, 0, 111, 48, 112, 0, 45, 117, 0, 70, 117, 0, 71, 117, 0, 117, 0, 
30, 49, 103, 50, 0, 31, 49, 103, 50, 0, 32, 49, 103, 47, 103, 50, 0, 33, 
49, 103, 50, 0, 38, 49, 130, 50, 0, 34, 49, 103, 50, 0, 35, 49, 103, 50, 
0, 37, 49, 103, 50, 0, 36, 49, 103, 50, 0, 114, 0, 39, 49, 103, 47, 103, 
50, 0, 39, 49, 103, 47, 103, 47, 103, 50, 0, 88, 49, 116, 50, 0, 65, 0, 
103, 0, 103, 47, 116, 0, 49, 103, 50, 0, 113, 0, 88, 0, 115, 0, 133, 0, 
132, 0, 134, 0, 136, 0, 130, 0, 0, 120, 0, 120, 119, 12, 118, 0, 120, 119, 
118, 0, 119, 12, 118, 0, 119, 118, 0, 21, 49, 103, 50, 0, 21, 113, 0, 21, 
115, 0, 120, 12, 121, 0, 120, 12, 0, 121, 0, 130, 123, 0, 131, 123, 0, 
51, 123, 52, 122, 0, 128, 123, 0, 128, 0, 123, 0, 0, 126, 124, 0, 126, 
124, 53, 123, 0, 126, 124, 53, 0, 125, 0, 124, 47, 125, 0, 130, 0, 127, 
0, 131, 0, 130, 0, 88, 0, 40, 0, 128, 0, 51, 122, 52, 0, 49, 129, 50, 0, 
125, 0, 129, 125, 0, 9, 0, 88, 0, 133, 0, 132, 0, 70, 132, 0, 71, 132, 
0, 134, 0, 136, 0, 65, 0, 54, 0, 55, 0, 56, 0, 135, 0, 135, 67, 0, 135, 
46, 88, 0, 41, 0, 42, 0, 57, 61, 57, 0, 59, 62, 59, 0, 58, 63, 58, 0, 60, 
64, 60, 0, 66, 0, 8, 0};

/* vector of line numbers and filename of all rules */
static const char* const rule_info[] = {
    ": line 0",
    "SPARQL.bgen: line 42",
    "SPARQL.bgen: line 49",
    "SPARQL.bgen: line 59",
    "SPARQL.bgen: line 80",
    "SPARQL.bgen: line 87",
    "SPARQL.bgen: line 97",
    "SPARQL.bgen: line 100",
    "SPARQL.bgen: line 109",
    "SPARQL.bgen: line 117",
    "SPARQL.bgen: line 131",
    "SPARQL.bgen: line 146",
    "SPARQL.bgen: line 160",
    "SPARQL.bgen: line 169",
    "SPARQL.bgen: line 179",
    "SPARQL.bgen: line 189",
    "SPARQL.bgen: line 205",
    "SPARQL.bgen: line 208",
    "SPARQL.bgen: line 218",
    "SPARQL.bgen: line 226",
    "SPARQL.bgen: line 240",
    "SPARQL.bgen: line 248",
    "SPARQL.bgen: line 257",
    "SPARQL.bgen: line 263",
    "SPARQL.bgen: line 275",
    "SPARQL.bgen: line 286",
    "SPARQL.bgen: line 304",
    "SPARQL.bgen: line 314",
    "SPARQL.bgen: line 330",
    "SPARQL.bgen: line 337",
    "SPARQL.bgen: line 349",
    "SPARQL.bgen: line 354",
    "SPARQL.bgen: line 360",
    "SPARQL.bgen: line 367",
    "SPARQL.bgen: line 375",
    "SPARQL.bgen: line 382",
    "SPARQL.bgen: line 389",
    "SPARQL.bgen: line 395",
    "SPARQL.bgen: line 406",
    "SPARQL.bgen: line 419",
    "SPARQL.bgen: line 427",
    "SPARQL.bgen: line 441",
    "SPARQL.bgen: line 452",
    "SPARQL.bgen: line 463",
    "SPARQL.bgen: line 466",
    "SPARQL.bgen: line 476",
    "SPARQL.bgen: line 484",
    "SPARQL.bgen: line 497",
    "SPARQL.bgen: line 511",
    "SPARQL.bgen: line 542",
    "SPARQL.bgen: line 549",
    "SPARQL.bgen: line 557",
    "SPARQL.bgen: line 610",
    "SPARQL.bgen: line 617",
    "SPARQL.bgen: line 657",
    "SPARQL.bgen: line 666",
    "SPARQL.bgen: line 687",
    "SPARQL.bgen: line 693",
    "SPARQL.bgen: line 705",
    "SPARQL.bgen: line 714",
    "SPARQL.bgen: line 729",
    "SPARQL.bgen: line 737",
    "SPARQL.bgen: line 747",
    "SPARQL.bgen: line 756",
    "SPARQL.bgen: line 781",
    "SPARQL.bgen: line 784",
    "SPARQL.bgen: line 792",
    "SPARQL.bgen: line 800",
    "SPARQL.bgen: line 808",
    "SPARQL.bgen: line 816",
    "SPARQL.bgen: line 824",
    "SPARQL.bgen: line 837",
    "SPARQL.bgen: line 843",
    "SPARQL.bgen: line 854",
    "SPARQL.bgen: line 863",
    "SPARQL.bgen: line 872",
    "SPARQL.bgen: line 882",
    "SPARQL.bgen: line 897",
    "SPARQL.bgen: line 903",
    "SPARQL.bgen: line 914",
    "SPARQL.bgen: line 923",
    "SPARQL.bgen: line 932",
    "SPARQL.bgen: line 942",
    "SPARQL.bgen: line 957",
    "SPARQL.bgen: line 964",
    "SPARQL.bgen: line 971",
    "SPARQL.bgen: line 978",
    "SPARQL.bgen: line 998",
    "SPARQL.bgen: line 1012",
    "SPARQL.bgen: line 1026",
    "SPARQL.bgen: line 1043",
    "SPARQL.bgen: line 1057",
    "SPARQL.bgen: line 1072",
    "SPARQL.bgen: line 1086",
    "SPARQL.bgen: line 1100",
    "SPARQL.bgen: line 1114",
    "SPARQL.bgen: line 1128",
    "SPARQL.bgen: line 1136",
    "SPARQL.bgen: line 1147",
    "SPARQL.bgen: line 1165",
    "SPARQL.bgen: line 1184",
    "SPARQL.bgen: line 1190",
    "SPARQL.bgen: line 1199",
    "SPARQL.bgen: line 1215",
    "SPARQL.bgen: line 1220",
    "SPARQL.bgen: line 1223",
    "SPARQL.bgen: line 1226",
    "SPARQL.bgen: line 1229",
    "SPARQL.bgen: line 1232",
    "SPARQL.bgen: line 1235",
    "SPARQL.bgen: line 1238",
    "SPARQL.bgen: line 1241",
    "SPARQLTurtleSuperSet.bgen.frag: line 6",
    "SPARQLTurtleSuperSet.bgen.frag: line 11",
    "SPARQLTurtleSuperSet.bgen.frag: line 19",
    "SPARQLTurtleSuperSet.bgen.frag: line 30",
    "SPARQLTurtleSuperSet.bgen.frag: line 40",
    "SPARQLTurtleSuperSet.bgen.frag: line 50",
    "SPARQLTurtleSuperSet.bgen.frag: line 66",
    "SPARQLTurtleSuperSet.bgen.frag: line 75",
    "SPARQLTurtleSuperSet.bgen.frag: line 82",
    "SPARQLTurtleSuperSet.bgen.frag: line 99",
    "SPARQLTurtleSuperSet.bgen.frag: line 109",
    "SPARQLTurtleSuperSet.bgen.frag: line 113",
    "SPARQLTurtleSuperSet.bgen.frag: line 139",
    "SPARQLTurtleSuperSet.bgen.frag: line 149",
    "SPARQLTurtleSuperSet.bgen.frag: line 159",
    "SPARQLTurtleSuperSet.bgen.frag: line 168",
    "SPARQLTurtleSuperSet.bgen.frag: line 175",
    "SPARQLTurtleSuperSet.bgen.frag: line 190",
    "SPARQLTurtleSuperSet.bgen.frag: line 193",
    "SPARQLTurtleSuperSet.bgen.frag: line 201",
    "SPARQLTurtleSuperSet.bgen.frag: line 209",
    "SPARQLTurtleSuperSet.bgen.frag: line 218",
    "SPARQLTurtleSuperSet.bgen.frag: line 234",
    "SPARQLTurtleSuperSet.bgen.frag: line 245",
    "SPARQLTurtleSuperSet.bgen.frag: line 268",
    "SPARQLTurtleSuperSet.bgen.frag: line 271",
    "SPARQLTurtleSuperSet.bgen.frag: line 274",
    "SPARQLTurtleSuperSet.bgen.frag: line 286",
    "SPARQLTurtleSuperSet.bgen.frag: line 289",
    "SPARQLTurtleSuperSet.bgen.frag: line 292",
    "SPARQLTurtleSuperSet.bgen.frag: line 310",
    "SPARQLTurtleSuperSet.bgen.frag: line 313",
    "SPARQLTurtleSuperSet.bgen.frag: line 328",
    "SPARQLTurtleSuperSet.bgen.frag: line 340",
    "SPARQLTurtleSuperSet.bgen.frag: line 348",
    "SPARQLTurtleSuperSet.bgen.frag: line 362",
    "SPARQLTurtleSuperSet.bgen.frag: line 381",
    "SPARQLTurtleSuperSet.bgen.frag: line 384",
    "SPARQLTurtleSuperSet.bgen.frag: line 387",
    "SPARQLTurtleSuperSet.bgen.frag: line 390",
    "SPARQLTurtleSuperSet.bgen.frag: line 394",
    "SPARQLTurtleSuperSet.bgen.frag: line 407",
    "SPARQLTurtleSuperSet.bgen.frag: line 410",
    "SPARQLTurtleSuperSet.bgen.frag: line 413",
    "SPARQLTurtleSuperSet.bgen.frag: line 425",
    "SPARQLTurtleSuperSet.bgen.frag: line 437",
    "SPARQLTurtleSuperSet.bgen.frag: line 449",
    "SPARQLTurtleSuperSet.bgen.frag: line 465",
    "SPARQLTurtleSuperSet.bgen.frag: line 471",
    "SPARQLTurtleSuperSet.bgen.frag: line 480",
    "SPARQLTurtleSuperSet.bgen.frag: line 493",
    "SPARQLTurtleSuperSet.bgen.frag: line 496",
    "SPARQLTurtleSuperSet.bgen.frag: line 507",
    "SPARQLTurtleSuperSet.bgen.frag: line 515",
    "SPARQLTurtleSuperSet.bgen.frag: line 523",
    "SPARQLTurtleSuperSet.bgen.frag: line 531",
    "SPARQLTurtleSuperSet.bgen.frag: line 544",
    "SPARQLTurtleSuperSet.bgen.frag: line 550",
};

/* vector of string-names indexed by token number */
static const char* const token_names[] = {
    "<EOF>",
    "error",
    "$undefined.",
    "WHITESPACE",
    "UNION",
    "QNAME",
    "QNAME_NS",
    "Q_IRI_CONTENT",
    "BLANK_NODE_LABEL",
    "VARNAME",
    "PREFIX",
    "ASTERISK",
    "DOT",
    "QUESTION_MARK",
    "DOLLAR",
    "BASE",
    "SELECT",
    "DISTINCT",
    "FROM",
    "NAMED",
    "OPTIONAL",
    "FILTER",
    "GRAPH",
    "WHERE",
    "ORDER",
    "BY",
    "ASC",
    "DESC",
    "LIMIT",
    "OFFSET",
    "STR",
    "LANG",
    "LANGMATCHES",
    "DATATYPE",
    "isIRI",
    "isURI",
    "isLITERAL",
    "isBLANK",
    "BOUND",
    "REGEX",
    "A",
    "TRUE",
    "FALSE",
    "DOUBLE_AMPERSAND",
    "DOUBLE_PIPE",
    "BANG",
    "DOUBLE_HAT",
    "COMMA",
    "FORWARDSLASH",
    "LEFT_PAREN",
    "RIGHT_PAREN",
    "LEFT_SQUARE",
    "RIGHT_SQUARE",
    "SEMICOLON",
    "INTEGER",
    "DECIMAL",
    "DOUBLE",
    "STRING_LITERAL_DELIMETER_1",
    "STRING_LITERAL_DELIMETER_2",
    "STRING_LITERAL_DELIMETER_3",
    "STRING_LITERAL_DELIMETER_4",
    "STRING_LITERAL1",
    "STRING_LITERAL2",
    "STRING_LITERAL_LONG1",
    "STRING_LITERAL_LONG2",
    "NIL",
    "ANON",
    "LANGTAG",
    "LEFT_CURLY",
    "RIGHT_CURLY",
    "PLUS",
    "MINUS",
    "EQUALITY_OP",
    "NOT_EQUAL",
    "LESS_THAN",
    "GREATER_THAN",
    "LESS_THAN_EQUAL",
    "GREATER_THAN_EQUAL",
    "Query",
    "QueryTypes",
    "Prolog",
    "OptionalPrefixDeclList",
    "PrefixDeclList",
    "PrefixDecl",
    "BaseDecl",
    "SelectQuery",
    "VAR_REFERENCES",
    "VariableReferenceList",
    "IRIref",
    "QName",
    "DataSetClauseList",
    "DataSetClause",
    "WhereClause",
    "SolutionModifier",
    "OrderClause",
    "OrderConditionList",
    "OrderCondition",
    "LimitClause",
    "OffsetClause",
    "GroupGraphPattern",
    "GraphPattern",
    "GraphPatternNotTriples",
    "AlternativeGroupGraphPatterns",
    "ConditionalOrExpression",
    "ConditionalAndExpressionList",
    "ConditionalAndExpression",
    "ValueLogicalList",
    "RelationalExpression",
    "AdditiveExpression",
    "MultiplicativeExpressionList",
    "MultiplicativeExpression",
    "UnaryExpressionList",
    "UnaryExpression",
    "BuiltInCall",
    "RegexExpression",
    "FunctionCall",
    "ArgumentList",
    "PrimaryExpression",
    "FilteredBasicGraphPattern",
    "Constraint",
    "Triples",
    "TriplesSameSubject",
    "PropertyList",
    "PropertyListNotEmpty",
    "ObjectList",
    "GraphNode",
    "Verb",
    "TriplesNode",
    "Collection",
    "GraphNodeList",
    "Var",
    "GraphTerm",
    "NumericLiteral",
    "RDFLiteral",
    "BooleanLiteral",
    "String",
    "BlankNode",
    "0",
};

/* symbol number of symbol that rule derives. */
static const int derives[] = {0, 78, 78, 79, 80, 80, 81, 81, 82, 82, 83, 
84, 85, 85, 85, 85, 86, 86, 87, 87, 88, 88, 89, 89, 90, 90, 91, 91, 92, 
92, 93, 93, 93, 93, 93, 93, 93, 93, 94, 95, 95, 96, 96, 96, 96, 96, 97, 
98, 99, 100, 100, 100, 101, 101, 102, 102, 103, 103, 104, 104, 105, 105, 
106, 106, 107, 107, 107, 107, 107, 107, 107, 108, 108, 109, 109, 109, 109, 
110, 110, 111, 111, 111, 111, 112, 112, 112, 112, 113, 113, 113, 113, 113, 
113, 113, 113, 113, 113, 114, 114, 115, 116, 116, 116, 117, 117, 117, 117, 
117, 117, 117, 117, 117, 118, 118, 118, 118, 118, 118, 119, 119, 119, 120, 
120, 120, 121, 121, 121, 121, 121, 122, 122, 123, 123, 123, 124, 124, 125, 
125, 125, 126, 126, 126, 127, 127, 128, 129, 129, 130, 131, 131, 131, 131, 
131, 131, 131, 131, 132, 132, 132, 133, 133, 133, 134, 134, 135, 135, 135, 
135, 136, 136};

/* number of symbols composing right hand side of rule. */
static const int rhs_size[] = {0, 2, 1, 1, 2, 1, 1, 0, 1, 2, 5, 4, 4, 5, 
5, 6, 1, 1, 1, 2, 3, 1, 1, 1, 1, 2, 2, 3, 2, 1, 0, 1, 2, 3, 2, 2, 1, 1, 
3, 1, 2, 4, 4, 1, 3, 1, 2, 2, 3, 1, 3, 4, 2, 2, 2, 3, 1, 2, 2, 3, 2, 1, 
2, 3, 1, 3, 3, 3, 3, 3, 3, 1, 2, 2, 2, 3, 3, 1, 2, 2, 2, 3, 3, 2, 2, 2, 
1, 4, 4, 6, 4, 4, 4, 4, 4, 4, 1, 6, 8, 4, 1, 1, 3, 3, 1, 1, 1, 1, 1, 1, 
1, 1, 0, 1, 4, 3, 3, 2, 4, 2, 2, 3, 2, 1, 2, 2, 4, 2, 1, 1, 0, 2, 4, 3, 
1, 3, 1, 1, 1, 1, 1, 1, 1, 3, 3, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 1, 
1, 1, 2, 3, 1, 1, 3, 3, 3, 3, 1, 1};

/* default rule to reduce with in state. 0 means the default is an error.
   indexed by state number */
static const int default_action[] = {0, 0, 0, 0, 2, 0, 5, 6, 8, 7, 3, 0, 
0, 147, 17, 0, 0, 16, 18, 1, 9, 4, 0, 0, 0, 0, 0, 112, 0, 24, 30, 29, 19, 
0, 11, 0, 30, 22, 23, 0, 0, 26, 21, 28, 169, 0, 162, 163, 0, 0, 156, 157, 
158, 0, 0, 0, 0, 155, 168, 0, 0, 148, 0, 49, 112, 113, 123, 128, 0, 0, 
150, 149, 153, 159, 154, 25, 30, 0, 0, 0, 12, 31, 37, 36, 10, 30, 14, 27, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 119, 96, 120, 130, 145, 137, 142, 
0, 136, 138, 141, 140, 0, 0, 139, 0, 0, 0, 0, 151, 152, 48, 0, 0, 112, 
112, 117, 122, 112, 127, 124, 125, 0, 160, 13, 0, 46, 47, 32, 35, 34, 15, 
20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 105, 0, 56, 61, 64, 71, 77, 
104, 106, 86, 111, 108, 107, 109, 110, 0, 0, 129, 144, 146, 130, 131, 134, 
164, 166, 165, 167, 52, 0, 53, 112, 50, 116, 121, 112, 115, 161, 0, 0, 
0, 38, 39, 43, 45, 33, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 84, 85, 118, 
0, 57, 0, 60, 0, 0, 0, 0, 0, 0, 0, 0, 72, 0, 0, 78, 100, 101, 0, 143, 126, 
0, 133, 54, 0, 51, 114, 0, 0, 0, 40, 87, 88, 0, 90, 92, 93, 95, 94, 91, 
0, 103, 58, 0, 62, 0, 65, 66, 67, 68, 69, 70, 73, 74, 0, 0, 79, 80, 0, 
0, 0, 99, 135, 132, 55, 0, 0, 44, 0, 0, 59, 63, 76, 75, 81, 82, 102, 41, 
42, 89, 0, 97, 0, 98, 0, 0, 0};

/* default state to go to after a reduction of a rule.
   indexed by variable number (lhs token) */
static const int default_goto[] = {302, 4, 5, 6, 7, 8, 9, 10, 16, 17, 158, 
42, 28, 29, 30, 80, 81, 198, 199, 82, 83, 31, 62, 125, 187, 235, 219, 160, 
221, 161, 162, 230, 163, 233, 164, 165, 102, 166, 236, 167, 63, 64, 65, 
66, 174, 175, 179, 105, 114, 106, 67, 108, 168, 69, 169, 170, 171, 73, 
172};

/* index in yytable of the portion describing state (indexed by state number)
   If the value in yytable is positive, we shift the token and go to that state.
   If the value is negative, it is minus a rule number to reduce by.
   If the value is zero, the default action from yydefact[s] is used. */
static const int action_idx[] = {210, 70, -30, 243, -32768, 64, -32768, 108, 
-32768, 108, -32768, 84, 137, -32768, -32768, 230, 97, 153, -32768, -32768, 
-32768, -32768, 167, 96, 97, 11, 115, 257, 97, -32768, 113, -32768, -32768, 
109, -32768, 97, 113, -32768, -32768, 13, 181, -32768, -32768, -32768, 
-32768, 251, -32768, -32768, 329, 20, -32768, -32768, -32768, 145, 146, 
149, 151, -32768, -32768, 239, 239, -32768, 147, -15, 355, 38, -32768, 
34, 34, 34, -32768, -32768, -32768, 73, -32768, -32768, 113, 199, 239, 
239, -32768, 125, 202, -32768, -32768, 113, -32768, -32768, 165, 193, 194, 
209, 215, 219, 220, 242, 252, 253, 254, 422, 255, -32768, -32768, -32768, 
72, -32768, -32768, -32768, 460, -32768, -32768, -32768, -32768, 207, 498, 
-32768, 248, 249, 250, 259, -32768, -32768, -32768, 115, 306, 565, 591, 
-32768, 658, 684, -32768, -32768, -32768, 26, -32768, -32768, 164, -32768, 
-32768, 202, -32768, -32768, -32768, -32768, 751, 751, 751, 751, 751, 751, 
751, 751, 153, 751, 807, 863, 919, 919, 255, 270, 277, 281, 200, -8, 24, 
-32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, 975, 274, 
-32768, -32768, -32768, 98, -19, -32768, -32768, -32768, -32768, -32768, 
-32768, 115, 325, 1017, -32768, -32768, -32768, 1017, -32768, -32768, 283, 
284, 1084, 396, -32768, -32768, -32768, -32768, 280, 286, 292, 290, 291, 
294, 297, 298, 299, 295, -32768, 300, -32768, -32768, -32768, 1140, 315, 
1140, 319, 1140, 1140, 1140, 1140, 1140, 1140, 1140, 1140, 131, 1140, 1140, 
36, -32768, 318, 316, -32768, -32768, 1178, 123, -32768, 115, -32768, -32768, 
1245, 1245, 322, -32768, -32768, -32768, 1245, -32768, -32768, -32768, 
-32768, -32768, -32768, 1245, -32768, -32768, 1245, -32768, 1245, -32768, 
-32768, -32768, -32768, -32768, -32768, -32768, -32768, 1245, 1245, -32768, 
-32768, 1245, 1245, 1301, -32768, -32768, -32768, -32768, 323, 324, -32768, 
327, 117, -32768, -32768, -32768, -32768, -32768, -32768, -32768, -32768, 
-32768, -32768, 1368, -32768, 331, -32768, 368, 369, -32768};

/* The index in yytable of the portion describing what to do after reducing a rule.
   The value from yytable is the state to go to. */
static const int goto_idx[] = {-32768, 370, -32768, 373, -32768, 372, -32768, 
-32768, 375, -32768, -12, -32768, 367, 54, 168, 12, -32768, -32768, 195, 
311, -40, -25, -105, -32768, -32768, 100, -32768, -210, -32768, -209, 130, 
-32768, -51, -32768, 3, 362, -32768, -43, 138, 25, -58, 343, -32768, 289, 
240, -46, -32768, -104, -32768, -32768, -41, -32768, -3, -39, 31, 22, 79, 
-32768, 104};

/* A vector filled with portions for different uses.
   (using action_idx and goto_idx) */
static const int yytable[] = {18, 43, 103, 113, 177, 123, 127, 107, 260, 
110, 180, 262, 18, 41, 32, 61, 37, 38, 37, 38, 189, 130, 131, 132, 68, 
37, 38, 87, 239, 13, 39, 37, 38, 100, 240, 231, 61, 112, 124, 37, 38, 140, 
141, 13, 12, 109, 115, 276, 86, 71, 128, 288, 61, 27, 289, 112, 112, 112, 
70, 45, 111, 68, 228, 229, 115, 115, 115, 107, 190, 110, 71, 193, 232, 
107, 111, 110, 11, 37, 38, 70, 3, 13, 75, 243, 277, 40, 71, 40, 135, 75, 
120, 121, 112, 200, 40, 70, 61, 142, 185, 202, 40, 115, 61, 37, 38, 109, 
72, 13, 40, 137, 138, 109, 111, 61, 61, 25, 61, 61, 1, 133, 26, 194, 68, 
68, 100, 68, 68, 72, 37, 38, 71, 74, 13, 201, 244, 280, 71, 77, 111, 70, 
134, 78, 79, 72, 23, 70, 40, 71, 71, 211, 71, 71, 74, 78, 79, 200, 70, 
70, 22, 70, 70, 241, 13, 111, 298, 27, 112, 299, 74, 37, 38, 34, 40, 13, 
33, 115, 61, 270, 271, 213, 61, 215, 216, 27, 84, 68, 100, 72, 88, 68, 
195, 196, 36, 72, 281, 201, 76, 40, 107, 159, 110, 272, 273, 85, 72, 72, 
116, 72, 72, 117, 71, 118, 74, 197, 71, 119, 122, 282, 74, 70, 1, 290, 
291, 70, 136, 2, 3, 61, 112, 74, 74, 79, 74, 74, 274, 275, 109, 115, 40, 
13, 143, 14, 144, 145, 203, 204, 205, 206, 207, 208, 209, 210, 13, 212, 
14, 214, 37, 38, 146, 178, 15, 71, 37, 38, 147, 44, 13, 72, 148, 149, 70, 
72, 222, 223, 224, 225, 226, 227, 45, 292, 293, 89, 90, 91, 92, 93, 94, 
95, 96, 97, 98, 150, 74, 50, 51, 52, 74, 247, 46, 47, 99, 151, 152, 153, 
173, 181, 48, 182, 49, 183, 186, 50, 51, 52, 53, 54, 55, 56, 72, 184, 217, 
218, 57, 58, 220, 40, 237, 59, 60, 242, 249, 40, 245, 246, 37, 38, 250, 
44, 13, 251, 252, 253, 258, 74, 254, 283, 284, 255, 256, 257, 259, 286, 
264, 265, 266, 267, 268, 269, 287, 261, 37, 38, 263, 44, 13, 278, 279, 
126, 303, 304, 46, 47, 285, 295, 296, 19, 45, 297, 48, 20, 104, 301, 21, 
50, 51, 52, 53, 54, 55, 56, 24, 35, 139, 248, 57, 58, 46, 47, 300, 59, 
60, 37, 38, 40, 48, 13, 49, 101, 129, 50, 51, 52, 53, 54, 55, 56, 294, 
191, 238, 0, 57, 58, 195, 196, 0, 59, 60, 37, 38, 40, 44, 13, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 197, 0, 0, 0, 0, 0, 0, 89, 90, 91, 92, 93, 
94, 95, 96, 97, 98, 0, 46, 47, 37, 38, 154, 44, 13, 40, 155, 0, 0, 0, 0, 
50, 51, 52, 53, 54, 55, 56, 0, 0, 0, 0, 0, 58, 0, 0, 0, 156, 157, 0, 0, 
40, 0, 0, 0, 0, 46, 47, 37, 38, 0, 44, 13, 0, 48, 176, 104, 0, 0, 50, 51, 
52, 53, 54, 55, 56, 0, 0, 0, 0, 57, 58, 0, 0, 0, 59, 60, 0, 0, 40, 0, 0, 
0, 0, 46, 47, 0, 0, 0, 0, 0, 0, 48, 0, 104, 0, 0, 50, 51, 52, 53, 54, 55, 
56, 0, 0, 0, 0, 57, 58, 0, 0, 0, 59, 60, 37, 38, 40, 44, 13, 0, 0, 188, 
0, 0, 0, 0, 0, 0, 0, 0, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 37, 38, 0, 44, 13, 
0, 0, 0, 0, 0, 46, 47, 0, 0, 0, 0, 45, 0, 48, 0, 49, 0, 0, 50, 51, 52, 
53, 54, 55, 56, 0, 0, 0, 0, 57, 58, 46, 47, 0, 59, 60, 0, 0, 40, 48, 0, 
49, 0, 0, 50, 51, 52, 53, 54, 55, 56, 0, 0, 0, 0, 57, 58, 0, 0, 0, 59, 
60, 37, 38, 40, 44, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 37, 38, 0, 44, 13, 0, 0, 192, 0, 0, 46, 47, 0, 0, 0, 0, 
45, 0, 48, 0, 49, 0, 0, 50, 51, 52, 53, 54, 55, 56, 0, 0, 0, 0, 57, 58, 
46, 47, 0, 59, 60, 0, 0, 40, 48, 0, 49, 0, 0, 50, 51, 52, 53, 54, 55, 56, 
0, 0, 0, 0, 57, 58, 0, 0, 0, 59, 60, 37, 38, 40, 44, 13, 0, 0, 0, 0, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 90, 91, 92, 93, 94, 95, 
96, 97, 98, 0, 46, 47, 0, 0, 154, 0, 0, 0, 155, 0, 0, 0, 0, 50, 51, 52, 
53, 54, 55, 56, 37, 38, 0, 44, 13, 58, 0, 0, 0, 156, 157, 0, 0, 40, 0, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 0, 
46, 47, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 0, 50, 51, 52, 53, 54, 55, 56, 
37, 38, 0, 44, 13, 58, 0, 0, 0, 0, 0, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 
0, 0, 0, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 0, 46, 47, 0, 0, 154, 
0, 0, 0, 155, 0, 0, 0, 0, 50, 51, 52, 53, 54, 55, 56, 37, 38, 0, 44, 13, 
58, 0, 0, 0, 156, 157, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 90, 
91, 92, 93, 94, 95, 96, 97, 98, 0, 46, 47, 0, 0, 0, 0, 0, 0, 155, 0, 0, 
0, 0, 50, 51, 52, 53, 54, 55, 56, 37, 38, 0, 44, 13, 58, 0, 0, 0, 0, 0, 
0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 90, 91, 92, 93, 94, 95, 
96, 97, 98, 0, 46, 47, 0, 0, 154, 0, 37, 38, 155, 44, 13, 0, 0, 50, 51, 
52, 53, 54, 55, 56, 0, 0, 45, 0, 234, 58, 0, 0, 0, 156, 157, 0, 0, 40, 
0, 0, 0, 0, 0, 0, 0, 0, 46, 47, 0, 0, 0, 0, 0, 0, 48, 0, 49, 0, 0, 50, 
51, 52, 53, 54, 55, 56, 0, 0, 0, 0, 57, 58, 0, 0, 0, 59, 60, 37, 38, 40, 
44, 13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 
90, 91, 92, 93, 94, 95, 96, 97, 98, 0, 46, 47, 0, 0, 154, 0, 0, 0, 155, 
0, 0, 0, 0, 50, 51, 52, 53, 54, 55, 56, 37, 38, 0, 44, 13, 58, 0, 0, 0, 
156, 157, 0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 90, 91, 92, 93, 
94, 95, 96, 97, 98, 0, 46, 47, 37, 38, 154, 44, 13, 0, 155, 0, 0, 0, 0, 
50, 51, 52, 53, 54, 55, 56, 0, 0, 0, 0, 0, 58, 0, 0, 0, 156, 157, 0, 0, 
40, 0, 0, 0, 0, 46, 47, 0, 0, 0, 0, 0, 0, 48, 0, 104, 0, 0, 50, 51, 52, 
53, 54, 55, 56, 0, 0, 0, 0, 57, 58, 0, 0, 0, 59, 60, 37, 38, 40, 44, 13, 
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 90, 91, 
92, 93, 94, 95, 96, 97, 98, 0, 46, 47, 0, 0, 154, 0, 0, 0, 155, 0, 0, 0, 
0, 50, 51, 52, 53, 54, 55, 56, 37, 38, 0, 44, 13, 58, 0, 0, 0, 156, 157, 
0, 0, 40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 90, 91, 92, 93, 94, 95, 
96, 97, 98, 0, 46, 47, 0, 0, 154, 0, 0, 0, 155, 0, 0, 0, 0, 50, 51, 52, 
53, 54, 55, 56, 0, 0, 0, 0, 234, 58, 0, 0, 0, 156, 157, 37, 38, 40, 44, 
13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 89, 90, 
91, 92, 93, 94, 95, 96, 97, 98, 0, 46, 47, 0, 0, 154, 0, 0, 0, 155, 0, 
0, 0, 0, 50, 51, 52, 53, 54, 55, 56, 0, 0, 0, 0, 0, 58, 0, 0, 0, 156, 157, 
0, 0, 40};

/* a vector indexed in parallel with yytable.
   It indicates the bounds of the portion you are trying to examine. */
static const int yycheck[] = {3, 26, 45, 49, 108, 20, 64, 48, 218, 48, 114, 
220, 15, 25, 17, 27, 5, 6, 5, 6, 125, 67, 68, 69, 27, 5, 6, 39, 47, 9, 
19, 5, 6, 45, 53, 11, 48, 49, 63, 5, 6, 81, 82, 9, 74, 48, 49, 11, 36, 
27, 12, 261, 64, 68, 263, 67, 68, 69, 27, 21, 40, 64, 70, 71, 67, 68, 69, 
108, 126, 108, 48, 129, 48, 114, 40, 114, 6, 5, 6, 48, 16, 9, 28, 188, 
48, 74, 64, 74, 76, 35, 59, 60, 104, 136, 74, 64, 108, 85, 123, 139, 74, 
104, 114, 5, 6, 108, 27, 9, 74, 78, 79, 114, 40, 125, 126, 18, 128, 129, 
10, 46, 23, 133, 125, 126, 136, 128, 129, 48, 5, 6, 108, 27, 9, 136, 192, 
239, 114, 24, 40, 108, 67, 28, 29, 64, 7, 114, 74, 125, 126, 152, 128, 
129, 48, 28, 29, 198, 125, 126, 74, 128, 129, 186, 9, 40, 47, 68, 178, 
50, 64, 5, 6, 75, 74, 9, 7, 178, 188, 228, 229, 154, 192, 156, 157, 68, 
75, 188, 198, 108, 7, 192, 26, 27, 24, 114, 240, 198, 28, 74, 239, 99, 
239, 70, 71, 35, 125, 126, 61, 128, 129, 63, 188, 62, 108, 49, 192, 64, 
69, 242, 114, 188, 10, 272, 273, 192, 25, 15, 16, 239, 240, 125, 126, 29, 
128, 129, 231, 232, 239, 240, 74, 9, 75, 11, 49, 49, 144, 145, 146, 147, 
148, 149, 150, 151, 9, 153, 11, 155, 5, 6, 49, 52, 17, 239, 5, 6, 49, 8, 
9, 188, 49, 49, 239, 192, 72, 73, 74, 75, 76, 77, 21, 276, 277, 30, 31, 
32, 33, 34, 35, 36, 37, 38, 39, 49, 188, 54, 55, 56, 192, 197, 41, 42, 
49, 49, 49, 49, 49, 57, 49, 58, 51, 59, 4, 54, 55, 56, 57, 58, 59, 60, 
239, 60, 50, 44, 65, 66, 43, 74, 52, 70, 71, 4, 50, 74, 49, 49, 5, 6, 50, 
8, 9, 47, 50, 50, 47, 239, 50, 245, 246, 50, 50, 50, 50, 251, 222, 223, 
224, 225, 226, 227, 258, 44, 5, 6, 43, 8, 9, 47, 50, 12, 0, 0, 41, 42, 
50, 50, 50, 5, 21, 50, 49, 7, 51, 50, 9, 54, 55, 56, 57, 58, 59, 60, 15, 
24, 81, 198, 65, 66, 41, 42, 298, 70, 71, 5, 6, 74, 49, 9, 51, 45, 65, 
54, 55, 56, 57, 58, 59, 60, 278, 128, 178, -1, 65, 66, 26, 27, -1, 70, 
71, 5, 6, 74, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
49, -1, -1, -1, -1, -1, -1, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, -1, 
41, 42, 5, 6, 45, 8, 9, 74, 49, -1, -1, -1, -1, 54, 55, 56, 57, 58, 59, 
60, -1, -1, -1, -1, -1, 66, -1, -1, -1, 70, 71, -1, -1, 74, -1, -1, -1, 
-1, 41, 42, 5, 6, -1, 8, 9, -1, 49, 50, 51, -1, -1, 54, 55, 56, 57, 58, 
59, 60, -1, -1, -1, -1, 65, 66, -1, -1, -1, 70, 71, -1, -1, 74, -1, -1, 
-1, -1, 41, 42, -1, -1, -1, -1, -1, -1, 49, -1, 51, -1, -1, 54, 55, 56, 
57, 58, 59, 60, -1, -1, -1, -1, 65, 66, -1, -1, -1, 70, 71, 5, 6, 74, 8, 
9, -1, -1, 12, -1, -1, -1, -1, -1, -1, -1, -1, 21, -1, -1, -1, -1, -1, 
-1, -1, -1, -1, 5, 6, -1, 8, 9, -1, -1, -1, -1, -1, 41, 42, -1, -1, -1, 
-1, 21, -1, 49, -1, 51, -1, -1, 54, 55, 56, 57, 58, 59, 60, -1, -1, -1, 
-1, 65, 66, 41, 42, -1, 70, 71, -1, -1, 74, 49, -1, 51, -1, -1, 54, 55, 
56, 57, 58, 59, 60, -1, -1, -1, -1, 65, 66, -1, -1, -1, 70, 71, 5, 6, 74, 
8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-1, -1, -1, -1, 5, 6, -1, 8, 9, -1, -1, 12, -1, -1, 41, 42, -1, -1, -1, 
-1, 21, -1, 49, -1, 51, -1, -1, 54, 55, 56, 57, 58, 59, 60, -1, -1, -1, 
-1, 65, 66, 41, 42, -1, 70, 71, -1, -1, 74, 49, -1, 51, -1, -1, 54, 55, 
56, 57, 58, 59, 60, -1, -1, -1, -1, 65, 66, -1, -1, -1, 70, 71, 5, 6, 74, 
8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-1, -1, -1, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, -1, 41, 42, -1, -1, 
45, -1, -1, -1, 49, -1, -1, -1, -1, 54, 55, 56, 57, 58, 59, 60, 5, 6, -1, 
8, 9, 66, -1, -1, -1, 70, 71, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, 
-1, -1, -1, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, -1, 41, 42, -1, -1, 
-1, -1, -1, -1, 49, -1, -1, -1, -1, 54, 55, 56, 57, 58, 59, 60, 5, 6, -1, 
8, 9, 66, -1, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, 
-1, -1, -1, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, -1, 41, 42, -1, -1, 
45, -1, -1, -1, 49, -1, -1, -1, -1, 54, 55, 56, 57, 58, 59, 60, 5, 6, -1, 
8, 9, 66, -1, -1, -1, 70, 71, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, 
-1, -1, -1, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, -1, 41, 42, -1, -1, 
-1, -1, -1, -1, 49, -1, -1, -1, -1, 54, 55, 56, 57, 58, 59, 60, 5, 6, -1, 
8, 9, 66, -1, -1, -1, -1, -1, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, 
-1, -1, -1, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, -1, 41, 42, -1, -1, 
45, -1, 5, 6, 49, 8, 9, -1, -1, 54, 55, 56, 57, 58, 59, 60, -1, -1, 21, 
-1, 65, 66, -1, -1, -1, 70, 71, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, 
-1, 41, 42, -1, -1, -1, -1, -1, -1, 49, -1, 51, -1, -1, 54, 55, 56, 57, 
58, 59, 60, -1, -1, -1, -1, 65, 66, -1, -1, -1, 70, 71, 5, 6, 74, 8, 9, 
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-1, -1, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, -1, 41, 42, -1, -1, 45, 
-1, -1, -1, 49, -1, -1, -1, -1, 54, 55, 56, 57, 58, 59, 60, 5, 6, -1, 8, 
9, 66, -1, -1, -1, 70, 71, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, 
-1, -1, -1, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, -1, 41, 42, 5, 6, 45, 
8, 9, -1, 49, -1, -1, -1, -1, 54, 55, 56, 57, 58, 59, 60, -1, -1, -1, -1, 
-1, 66, -1, -1, -1, 70, 71, -1, -1, 74, -1, -1, -1, -1, 41, 42, -1, -1, 
-1, -1, -1, -1, 49, -1, 51, -1, -1, 54, 55, 56, 57, 58, 59, 60, -1, -1, 
-1, -1, 65, 66, -1, -1, -1, 70, 71, 5, 6, 74, 8, 9, -1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30, 31, 32, 
33, 34, 35, 36, 37, 38, 39, -1, 41, 42, -1, -1, 45, -1, -1, -1, 49, -1, 
-1, -1, -1, 54, 55, 56, 57, 58, 59, 60, 5, 6, -1, 8, 9, 66, -1, -1, -1, 
70, 71, -1, -1, 74, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30, 31, 
32, 33, 34, 35, 36, 37, 38, 39, -1, 41, 42, -1, -1, 45, -1, -1, -1, 49, 
-1, -1, -1, -1, 54, 55, 56, 57, 58, 59, 60, -1, -1, -1, -1, 65, 66, -1, 
-1, -1, 70, 71, 5, 6, 74, 8, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 30, 31, 32, 33, 34, 35, 36, 37, 
38, 39, -1, 41, 42, -1, -1, 45, -1, -1, -1, 49, -1, -1, -1, -1, 54, 55, 
56, 57, 58, 59, 60, -1, -1, -1, -1, -1, 66, -1, -1, -1, 70, 71, -1, -1, 
74};

#define YYLAST 1442
#define YYFINAL 304
#define YYFLAG -32768
#define YYNTBASE 78

#define LEXER_OP_FAILURE 0
#define LEXER_OP_SUCCESS 1
#define LEXER_OP_BOL 2
#define LEXER_OP_EOL 3
#define LEXER_OP_EOF 4
#define LEXER_OP_ANY 5
#define LEXER_OP_LITERAL 6
#define LEXER_OP_NOT_LITERAL 7
#define LEXER_OP_CHARSET 8
#define LEXER_OP_NOT_CHARSET 9
#define LEXER_OP_ASSERT 10
#define LEXER_OP_BRANCH 11
#define LEXER_OP_REPEAT 12
#define LEXER_OP_REPEAT_RANGE 13

#define LEXER_CHARSET_FAILURE 0
#define LEXER_CHARSET_LITERAL 1
#define LEXER_CHARSET_RANGE 2
#define LEXER_CHARSET_SMALL 3
#define LEXER_CHARSET_BIG 4

#define LEXER_INITIAL 1
#define LEXER_STRING_MODE_SHORT_2 2
#define LEXER_STRING_MODE_LONG_2 3
#define LEXER_STRING_MODE_LONG_1 4
#define LEXER_STRING_MODE_SHORT_1 5
#define LEXER_IRI_MODE 6
#define LEXER_START_STATE LEXER_INITIAL

static unsigned char lexer_charsets[70][32] = {
  { 0xFF, 0xFF, 0xFF, 0xFF, 0x81, 0x00, 0x00, 0x50, 0x00, 0x00, 0x00, 0x40,
    0x01, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x26, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07,
    0xFE, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 0xFE, 0xFF, 0xFF, 0x07,
    0xFE, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07,
    0xFE, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF3, 0x7F, 0xFE, 0xFD, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x0F, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x31, 0xFC },
  { 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0xF8,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0xD7, 0xFF, 0xFF, 0xFB, 0xFF, 0xFF, 0xFF,
    0xFF, 0x7F, 0x7F, 0x54, 0xFD, 0xFF, 0x0F, 0x00 },
  { 0xFE, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xDF,
    0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0x9F, 0x19, 0xFF, 0xFF, 0xFF, 0xCF, 0x3F, 0x03 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x02,
    0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x07, 0x07, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0x07, 0xFE, 0x07, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7C,
    0xFF, 0x7F, 0x2F, 0x00, 0x60, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x23, 0x00, 0x00, 0x00, 0xFF,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xC5, 0x03,
    0x00, 0x00, 0x00, 0xB0, 0x03, 0x00, 0x03, 0x00 },
  { 0xE0, 0x87, 0xF9, 0xFF, 0xFF, 0xFD, 0x6D, 0x03, 0x00, 0x00, 0x00, 0x5E,
    0x00, 0x00, 0x1C, 0x00, 0xE0, 0xAF, 0xFB, 0xFF, 0xFF, 0xFD, 0xED, 0x23,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00 },
  { 0xE0, 0x9F, 0xF9, 0xFF, 0xFF, 0xFD, 0xCD, 0x23, 0x00, 0x00, 0x00, 0xB0,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0xC7, 0x3D, 0xD6, 0x18, 0xC7, 0xBF, 0x03,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xEF, 0x03,
    0x00, 0x00, 0x00, 0x40, 0x03, 0x00, 0x00, 0x00 },
  { 0xE0, 0xDF, 0xFD, 0xFF, 0xFF, 0xFD, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x0D, 0x00, 0x3F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x96, 0x25, 0xF0, 0xFE, 0xAE, 0x6C, 0x0D, 0x20,
    0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFE, 0xFF, 0xFF,
    0xFF, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
    0x3F, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x00 },
  { 0xED, 0xDA, 0x07, 0x00, 0x00, 0x00, 0x00, 0x50, 0x01, 0x50, 0x31, 0x82,
    0xAB, 0x62, 0x2C, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xC9, 0x80, 0xF5,
    0x07, 0x00, 0x00, 0x00, 0x00, 0x08, 0x01, 0x02 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03 },
  { 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x3F, 0xFF, 0xAA,
    0xFF, 0xFF, 0xFF, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xDF, 0x5F,
    0xDC, 0x1F, 0xCF, 0x0F, 0xFF, 0x1F, 0xDC, 0x1F },
  { 0x00, 0x00, 0x00, 0x00, 0x40, 0x4C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x07 },
  { 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x80, 0x00, 0x00, 0x00, 0xFE, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x03, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x00, 0x00, 0x00,
    0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFB, 0xFF, 0xFF, 0xBB,
    0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x07, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xC0, 0xFF, 0x9F, 0x3D, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xFF, 0x3F, 0x1E, 0x00,
    0x0C, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0,
    0x9F, 0x39, 0x80, 0x00, 0x0C, 0x00, 0x00, 0x00 },
  { 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x87, 0x39, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0,
    0xBF, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0x8F, 0x39, 0xC0, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
    0xC7, 0x3D, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xDF, 0x3D, 0x60, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0,
    0xDF, 0x3D, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xCF, 0x3D, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x07, 0x80, 0x7F, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF2, 0x1B,
    0x00, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0xA0, 0xC2, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFE, 0xFF, 0xDF, 0x0F, 0xBF, 0xFE, 0xFF, 0x3F, 0xFE, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0x1F, 0x02, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x70 },
  { 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xBF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
  { 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00 },
  { 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF },
  { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x24, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x44, 0x40, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x24, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
  { 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
};

static unsigned char lexer_blockmaps[6][256] = {
  { 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0B, 0x0C, 0x0D, 0x0E,
    0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x15, 0x16, 0x0B, 0x17, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x18, 0x19, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B },
  { 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x1C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1D, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B },
  { 0x0B, 0x0B, 0x0B, 0x20, 0x21, 0x22, 0x23, 0x0B, 0x0B, 0x24, 0x25, 0x26,
    0x27, 0x28, 0x29, 0x2A, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x2B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x2C, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B },
  { 0x2D, 0x0B, 0x2E, 0x2F, 0x0B, 0x0B, 0x30, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x31, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x32, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B },
  { 0x34, 0x1A, 0x1A, 0x35, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x36, 0x37, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x1A, 0x1A, 0x1A, 0x38,
    0x39, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x3A },
  { 0x3B, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A,
    0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x1A, 0x3C, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B, 0x0B,
    0x0B, 0x0B, 0x0B, 0x0B },
};

static const Py_UCS4 lexer_INITIAL_pattern_0[] = { 6, 39, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_1[] = { 6, 39, 6, 39, 6, 39, 
  1 };

static const Py_UCS4 lexer_INITIAL_pattern_2[] = { 6, 34, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_3[] = { 6, 34, 6, 34, 6, 34, 
  1 };

static const Py_UCS4 lexer_INITIAL_pattern_4[] = { 6, 60, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_5[] = { 6, 64, 12, 8, 1, 8, 
  4, 3, 2, 0, 1, 12, 14, 0, 6, 45, 12, 8, 1, 8, 4, 3, 3, 0, 1, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_6[] = { 6, 40, 12, 8, 0, 8, 
  4, 3, 1, 0, 1, 6, 41, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_7[] = { 6, 91, 12, 8, 0, 8, 
  4, 3, 1, 0, 1, 6, 93, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_8[] = { 13, 80, 0, 1, 11, 4, 
  6, 95, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 
  12, 51, 0, 11, 7, 8, 4, 3, 30, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 
  8, 4, 4, 1, 0, 1, 0, 1, 7, 8, 4, 3, 31, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 
  8, 4, 4, 3, 0, 1, 0, 1, 1, 6, 58, 11, 4, 6, 95, 1, 18, 11, 7, 8, 4, 4, 
  0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 12, 51, 0, 11, 7, 8, 4, 3, 30, 
  0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 7, 8, 4, 
  3, 31, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 8, 4, 4, 3, 0, 1, 0, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_9[] = { 13, 80, 0, 1, 11, 4, 
  6, 95, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 
  12, 51, 0, 11, 7, 8, 4, 3, 30, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 
  8, 4, 4, 1, 0, 1, 0, 1, 7, 8, 4, 3, 31, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 
  8, 4, 4, 3, 0, 1, 0, 1, 1, 6, 58, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_10[] = { 6, 95, 6, 58, 11, 4, 
  6, 95, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 8, 4, 4, 1, 0, 1, 0, 1, 0, 
  12, 51, 0, 11, 7, 8, 4, 3, 30, 0, 1, 18, 11, 7, 8, 4, 4, 0, 0, 1, 7, 
  8, 4, 4, 1, 0, 1, 0, 1, 7, 8, 4, 3, 31, 0, 1, 7, 8, 4, 4, 2, 0, 1, 7, 
  8, 4, 4, 3, 0, 1, 0, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_11[] = { 8, 4, 3, 51, 0, 11, 
  15, 11, 4, 6, 95, 1, 7, 8, 4, 4, 4, 0, 1, 0, 1, 7, 8, 4, 3, 31, 0, 1, 
  0, 12, 34, 0, 11, 7, 8, 4, 4, 5, 0, 1, 15, 11, 4, 6, 95, 1, 7, 8, 4, 
  4, 4, 0, 1, 0, 1, 7, 8, 4, 3, 31, 0, 1, 0, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_12[] = { 6, 64, 12, 8, 1, 8, 
  4, 3, 2, 0, 1, 12, 14, 0, 6, 45, 12, 8, 1, 8, 4, 3, 3, 0, 1, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_13[] = { 12, 8, 1, 8, 4, 3, 
  31, 0, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_14[] = { 11, 22, 12, 8, 1, 8, 
  4, 3, 31, 0, 1, 6, 46, 12, 8, 0, 8, 4, 3, 31, 0, 1, 1, 13, 6, 46, 12, 
  8, 1, 8, 4, 3, 31, 0, 1, 1, 0, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_15[] = { 11, 46, 12, 8, 1, 8, 
  4, 3, 31, 0, 1, 6, 46, 12, 8, 0, 8, 4, 3, 31, 0, 1, 8, 4, 3, 61, 0, 13, 
  9, 0, 1, 8, 4, 3, 62, 0, 1, 12, 8, 1, 8, 4, 3, 31, 0, 1, 1, 37, 6, 46, 
  12, 8, 1, 8, 4, 3, 31, 0, 1, 8, 4, 3, 61, 0, 13, 9, 0, 1, 8, 4, 3, 62, 
  0, 1, 12, 8, 1, 8, 4, 3, 31, 0, 1, 1, 35, 12, 8, 1, 8, 4, 3, 31, 0, 1, 
  8, 4, 3, 61, 0, 13, 9, 0, 1, 8, 4, 3, 62, 0, 1, 12, 8, 1, 8, 4, 3, 31, 
  0, 1, 1, 0, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_16[] = { 6, 35, 12, 8, 0, 9, 
  4, 3, 63, 0, 1, 13, 19, 0, 1, 11, 7, 8, 4, 3, 63, 0, 1, 6, 6, 13, 6, 
  10, 1, 0, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_17[] = { 12, 8, 1, 8, 4, 3, 
  1, 0, 1, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_18[] = { 6, 85, 6, 78, 6, 73, 
  6, 79, 6, 78, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_19[] = { 6, 42, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_20[] = { 6, 66, 6, 65, 6, 83, 
  6, 69, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_21[] = { 6, 80, 6, 82, 6, 69, 
  6, 70, 6, 73, 6, 88, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_22[] = { 6, 83, 6, 69, 6, 76, 
  6, 69, 6, 67, 6, 84, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_23[] = { 6, 68, 6, 73, 6, 83, 
  6, 84, 6, 73, 6, 78, 6, 67, 6, 84, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_24[] = { 6, 70, 6, 82, 6, 79, 
  6, 77, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_25[] = { 6, 78, 6, 65, 6, 77, 
  6, 69, 6, 68, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_26[] = { 6, 79, 6, 80, 6, 84, 
  6, 73, 6, 79, 6, 78, 6, 65, 6, 76, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_27[] = { 6, 70, 6, 73, 6, 76, 
  6, 84, 6, 69, 6, 82, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_28[] = { 6, 71, 6, 82, 6, 65, 
  6, 80, 6, 72, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_29[] = { 6, 87, 6, 72, 6, 69, 
  6, 82, 6, 69, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_30[] = { 6, 79, 6, 82, 6, 68, 
  6, 69, 6, 82, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_31[] = { 6, 66, 6, 89, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_32[] = { 6, 65, 6, 83, 6, 67, 
  1 };

static const Py_UCS4 lexer_INITIAL_pattern_33[] = { 6, 68, 6, 69, 6, 83, 
  6, 67, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_34[] = { 6, 76, 6, 73, 6, 77, 
  6, 73, 6, 84, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_35[] = { 6, 79, 6, 70, 6, 70, 
  6, 83, 6, 69, 6, 84, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_36[] = { 6, 83, 6, 84, 6, 82, 
  1 };

static const Py_UCS4 lexer_INITIAL_pattern_37[] = { 6, 76, 6, 65, 6, 78, 
  6, 71, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_38[] = { 6, 76, 6, 65, 6, 78, 
  6, 71, 6, 77, 6, 65, 6, 84, 6, 67, 6, 72, 6, 69, 6, 83, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_39[] = { 6, 68, 6, 65, 6, 84, 
  6, 65, 6, 84, 6, 89, 6, 80, 6, 69, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_40[] = { 6, 105, 6, 115, 6, 
  73, 6, 82, 6, 73, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_41[] = { 6, 105, 6, 115, 6, 
  85, 6, 82, 6, 73, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_42[] = { 6, 105, 6, 115, 6, 
  66, 6, 76, 6, 65, 6, 78, 6, 75, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_43[] = { 6, 105, 6, 115, 6, 
  76, 6, 73, 6, 84, 6, 69, 6, 82, 6, 65, 6, 76, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_44[] = { 11, 12, 6, 98, 6, 111, 
  6, 117, 6, 110, 6, 100, 1, 12, 6, 66, 6, 79, 6, 85, 6, 78, 6, 68, 1, 
  0, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_45[] = { 6, 82, 6, 69, 6, 71, 
  6, 69, 6, 88, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_46[] = { 6, 116, 6, 114, 6, 
  117, 6, 101, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_47[] = { 6, 102, 6, 97, 6, 108, 
  6, 115, 6, 101, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_48[] = { 6, 97, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_49[] = { 6, 45, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_50[] = { 6, 43, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_51[] = { 6, 38, 6, 38, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_52[] = { 6, 124, 6, 124, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_53[] = { 6, 33, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_54[] = { 6, 94, 6, 94, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_55[] = { 6, 44, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_56[] = { 6, 63, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_57[] = { 6, 36, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_58[] = { 6, 47, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_59[] = { 6, 40, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_60[] = { 6, 41, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_61[] = { 6, 91, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_62[] = { 6, 93, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_63[] = { 6, 61, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_64[] = { 6, 33, 6, 61, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_65[] = { 6, 60, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_66[] = { 6, 62, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_67[] = { 6, 60, 6, 61, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_68[] = { 6, 62, 6, 61, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_69[] = { 6, 59, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_70[] = { 6, 123, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_71[] = { 6, 125, 1 };

static const Py_UCS4 lexer_INITIAL_pattern_72[] = { 6, 46, 1 };

static const Py_UCS4 *lexer_INITIAL_patterns[] = {
  lexer_INITIAL_pattern_0,
  lexer_INITIAL_pattern_1,
  lexer_INITIAL_pattern_2,
  lexer_INITIAL_pattern_3,
  lexer_INITIAL_pattern_4,
  lexer_INITIAL_pattern_5,
  lexer_INITIAL_pattern_6,
  lexer_INITIAL_pattern_7,
  lexer_INITIAL_pattern_8,
  lexer_INITIAL_pattern_9,
  lexer_INITIAL_pattern_10,
  lexer_INITIAL_pattern_11,
  lexer_INITIAL_pattern_12,
  lexer_INITIAL_pattern_13,
  lexer_INITIAL_pattern_14,
  lexer_INITIAL_pattern_15,
  lexer_INITIAL_pattern_16,
  lexer_INITIAL_pattern_17,
  lexer_INITIAL_pattern_18,
  lexer_INITIAL_pattern_19,
  lexer_INITIAL_pattern_20,
  lexer_INITIAL_pattern_21,
  lexer_INITIAL_pattern_22,
  lexer_INITIAL_pattern_23,
  lexer_INITIAL_pattern_24,
  lexer_INITIAL_pattern_25,
  lexer_INITIAL_pattern_26,
  lexer_INITIAL_pattern_27,
  lexer_INITIAL_pattern_28,
  lexer_INITIAL_pattern_29,
  lexer_INITIAL_pattern_30,
  lexer_INITIAL_pattern_31,
  lexer_INITIAL_pattern_32,
  lexer_INITIAL_pattern_33,
  lexer_INITIAL_pattern_34,
  lexer_INITIAL_pattern_35,
  lexer_INITIAL_pattern_36,
  lexer_INITIAL_pattern_37,
  lexer_INITIAL_pattern_38,
  lexer_INITIAL_pattern_39,
  lexer_INITIAL_pattern_40,
  lexer_INITIAL_pattern_41,
  lexer_INITIAL_pattern_42,
  lexer_INITIAL_pattern_43,
  lexer_INITIAL_pattern_44,
  lexer_INITIAL_pattern_45,
  lexer_INITIAL_pattern_46,
  lexer_INITIAL_pattern_47,
  lexer_INITIAL_pattern_48,
  lexer_INITIAL_pattern_49,
  lexer_INITIAL_pattern_50,
  lexer_INITIAL_pattern_51,
  lexer_INITIAL_pattern_52,
  lexer_INITIAL_pattern_53,
  lexer_INITIAL_pattern_54,
  lexer_INITIAL_pattern_55,
  lexer_INITIAL_pattern_56,
  lexer_INITIAL_pattern_57,
  lexer_INITIAL_pattern_58,
  lexer_INITIAL_pattern_59,
  lexer_INITIAL_pattern_60,
  lexer_INITIAL_pattern_61,
  lexer_INITIAL_pattern_62,
  lexer_INITIAL_pattern_63,
  lexer_INITIAL_pattern_64,
  lexer_INITIAL_pattern_65,
  lexer_INITIAL_pattern_66,
  lexer_INITIAL_pattern_67,
  lexer_INITIAL_pattern_68,
  lexer_INITIAL_pattern_69,
  lexer_INITIAL_pattern_70,
  lexer_INITIAL_pattern_71,
  lexer_INITIAL_pattern_72,
  NULL
};

static const Py_UCS4 lexer_STRING_MODE_SHORT_2_pattern_0[] = { 12, 21, 
  0, 11, 7, 9, 4, 3, 64, 0, 1, 9, 6, 92, 8, 4, 3, 65, 0, 1, 0, 1, 1 };

static const Py_UCS4 lexer_STRING_MODE_SHORT_2_pattern_1[] = { 6, 34, 1 };

static const Py_UCS4 *lexer_STRING_MODE_SHORT_2_patterns[] = {
  lexer_STRING_MODE_SHORT_2_pattern_0,
  lexer_STRING_MODE_SHORT_2_pattern_1,
  NULL
};

static const Py_UCS4 lexer_STRING_MODE_LONG_2_pattern_0[] = { 12, 28, 0, 
  13, 6, 0, 2, 6, 34, 1, 11, 7, 9, 4, 3, 67, 0, 1, 9, 6, 92, 8, 4, 3, 65, 
  0, 1, 0, 1, 1 };

static const Py_UCS4 lexer_STRING_MODE_LONG_2_pattern_1[] = { 6, 34, 6, 
  34, 6, 34, 1 };

static const Py_UCS4 *lexer_STRING_MODE_LONG_2_patterns[] = {
  lexer_STRING_MODE_LONG_2_pattern_0,
  lexer_STRING_MODE_LONG_2_pattern_1,
  NULL
};

static const Py_UCS4 lexer_STRING_MODE_LONG_1_pattern_0[] = { 12, 28, 0, 
  6, 39, 8, 4, 3, 68, 0, 11, 7, 9, 4, 3, 69, 0, 1, 9, 6, 92, 8, 4, 3, 65, 
  0, 1, 0, 1, 1 };

static const Py_UCS4 lexer_STRING_MODE_LONG_1_pattern_1[] = { 6, 39, 6, 
  39, 6, 39, 1 };

static const Py_UCS4 *lexer_STRING_MODE_LONG_1_patterns[] = {
  lexer_STRING_MODE_LONG_1_pattern_0,
  lexer_STRING_MODE_LONG_1_pattern_1,
  NULL
};

static const Py_UCS4 lexer_STRING_MODE_SHORT_1_pattern_0[] = { 12, 21, 
  0, 11, 7, 9, 4, 3, 66, 0, 1, 9, 6, 92, 8, 4, 3, 65, 0, 1, 0, 1, 1 };

static const Py_UCS4 lexer_STRING_MODE_SHORT_1_pattern_1[] = { 6, 39, 1 };

static const Py_UCS4 *lexer_STRING_MODE_SHORT_1_patterns[] = {
  lexer_STRING_MODE_SHORT_1_pattern_0,
  lexer_STRING_MODE_SHORT_1_pattern_1,
  NULL
};

static const Py_UCS4 lexer_IRI_MODE_pattern_0[] = { 12, 8, 1, 9, 4, 3, 
  0, 0, 1, 1 };

static const Py_UCS4 lexer_IRI_MODE_pattern_1[] = { 6, 62, 1 };

static const Py_UCS4 lexer_IRI_MODE_pattern_2[] = { 11, 4, 6, 61, 1, 11, 
  12, 8, 1, 8, 4, 3, 1, 0, 1, 1, 0, 1 };

static const Py_UCS4 *lexer_IRI_MODE_patterns[] = {
  lexer_IRI_MODE_pattern_0,
  lexer_IRI_MODE_pattern_1,
  lexer_IRI_MODE_pattern_2,
  NULL
};

static const Py_UCS4 **lexer_patterns[] = {
  NULL,
  lexer_INITIAL_patterns,
  lexer_STRING_MODE_SHORT_2_patterns,
  lexer_STRING_MODE_LONG_2_patterns,
  lexer_STRING_MODE_LONG_1_patterns,
  lexer_STRING_MODE_SHORT_1_patterns,
  lexer_IRI_MODE_patterns
};

static const int lexer_INITIAL_actions[] = { 3, 4, 5, 6, 7, 8, 9, 10, 11, 
  12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 
  30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 
  48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 
  66, 67, 68, 69, 70, 71, 72, 73, 74, 75 };

static const int lexer_STRING_MODE_SHORT_2_actions[] = { 76, 77 };

static const int lexer_STRING_MODE_LONG_2_actions[] = { 80, 81 };

static const int lexer_STRING_MODE_LONG_1_actions[] = { 82, 83 };

static const int lexer_STRING_MODE_SHORT_1_actions[] = { 78, 79 };

static const int lexer_IRI_MODE_actions[] = { 0, 1, 2 };

static const int *lexer_actions[] = {
  NULL,
  lexer_INITIAL_actions,
  lexer_STRING_MODE_SHORT_2_actions,
  lexer_STRING_MODE_LONG_2_actions,
  lexer_STRING_MODE_LONG_1_actions,
  lexer_STRING_MODE_SHORT_1_actions,
  lexer_IRI_MODE_actions
};

#if PY_VERSION_HEX < 0x02020000 || !defined(Py_USING_UNICODE)
#error "Python 2.2+ with unicode support required"
#endif

/* Static Definitions */
#define YYEMPTY -2
#define YYERROR -1
#define YYEOF 0
#define YYINITDEPTH 1000
#define LEXER_INITIAL_BACKTRACKS 20

/* Parsing objects */
typedef struct {
  PyObject_HEAD
  int verbose;
  PyObject *dict;
} parserobject;

typedef struct {
  PyObject *text;
  int last;
  int state;
  Py_UNICODE *end;
  Py_UNICODE *position;

  /* backtracking stack */
  int backtracks;
  Py_UNICODE **positions;
  int allocated;
} lexerobject;

static int parser_yylex(parserobject *, lexerobject *, PyObject **);
static lexerobject *lexer_new(PyObject *);
static void lexer_free(lexerobject *);
static int lexer_save_position(lexerobject *);
static Py_UNICODE *lexer_restore_position(lexerobject *);
static int lexer_charset(parserobject *, Py_UCS4 *, Py_UCS4, int);
static int lexer_match(parserobject *, lexerobject *, Py_UCS4 *);
static void lexer_error(lexerobject *);

static char *unicode_escape(Py_UNICODE *, int);
static PyObject *report_error(int state, PyObject *lval, lexerobject *lexer);
static void print_reduce(int ruleno);
static void print_state_stack(int *stack, int *end);

/* Parser Methods */

/* Attempt to use C99 variable argument macros for improved error detection
 * (just in case). 
 */
#ifdef __STDC__ /* C99 conformance macro */
#define TRACE(...) if (self->verbose > 0) PySys_WriteStderr(__VA_ARGS__)
#define REGEX_TRACE(...) if (self->verbose > 1) PySys_WriteStderr(__VA_ARGS__)
#else
#define TRACE if (self->verbose > 0) PySys_WriteStderr
#define REGEX_TRACE if (self->verbose > 1) PySys_WriteStderr
#endif

static char parse_doc[] = "\
parse(string) -> object\n\
Converts the given string to a parse tree and return the top-most\n\
element of the tree.";

static PyObject* parser_parse(register parserobject *self, PyObject *text)
{
  register int yystate;
  register int yyn;

  PyObject *yylval = NULL;
  PyObject *yyval = NULL;

  int state_stack[YYINITDEPTH];
  int *state_ptr;
  PyObject *value_stack[YYINITDEPTH];
  PyObject **value_ptr;

  int yylen;
  int yychar = YYEMPTY;         /* cause a token to be read */
  int yychar1 = 0;

  lexerobject *lexer;

  lexer = lexer_new(text);
  if (lexer == NULL)
    return NULL;

  TRACE("Starting parse\n");

  /* Initialize stack pointers
     Waste one element of value and location stack
     so that they stay on the same level as the state stack.
     The wasted elements are never initialized. */
  state_ptr = state_stack - 1;
  value_ptr = value_stack;

  yystate = 0;

  while (1) {
    /* Push a new state, which is found in yystate. */
    /* In all cases, when you get here, the value and location stacks
       have just been pushed.  So pushing a state here evens the stacks. */
    *++state_ptr = yystate;

    TRACE("Entering state %d\n", yystate);

    /* Do appropriate processing given the current state. */
    /* Read a lookahead token if we need one and don't already have one. */

    /* First try to decide what to do without reference to lookahead token. */
    yyn = action_idx[yystate];
    if (yyn == YYFLAG) {
      yyn = default_action[yystate];
      if (yyn == 0) {
        return report_error(yystate, yylval, lexer);
      }

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 1: {
  /* from SPARQL.bgen, line 42
   * Query: Prolog QueryTypes
   */
  yyval = PyObject_CallMethod(Query, "Query", "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Query(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 2: {
  /* from SPARQL.bgen, line 49
   * Query: QueryTypes
   */
  yyval = PyObject_CallMethod(Query, "Query", "OO", Py_None, value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Query(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 3: {
  /* from SPARQL.bgen, line 59
   * QueryTypes: SelectQuery
   */
  yyval = value_ptr[1];
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--QueryTypes(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 4: {
  /* from SPARQL.bgen, line 80
   * Prolog: BaseDecl OptionalPrefixDeclList
   */
  yyval = PyObject_CallMethod(Query, "Prolog", "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Prolog(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 5: {
  /* from SPARQL.bgen, line 87
   * Prolog: OptionalPrefixDeclList
   */
  yyval = PyObject_CallMethod(Query, "Prolog", "OO", Py_None, value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Prolog(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 8: {
  /* from SPARQL.bgen, line 109
   * PrefixDeclList: PrefixDecl
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrefixDeclList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 9: {
  /* from SPARQL.bgen, line 117
   * PrefixDeclList: PrefixDeclList PrefixDecl
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--PrefixDeclList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 10: {
  /* from SPARQL.bgen, line 131
   * PrefixDecl: PREFIX QNAME_NS LESS_THAN Q_IRI_CONTENT GREATER_THAN
   */
  yyval = PyObject_CallMethod(Bindings, "PrefixDeclaration", "OO", value_ptr[2],value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--PrefixDecl(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  break;
}
case 11: {
  /* from SPARQL.bgen, line 146
   * BaseDecl: BASE LESS_THAN Q_IRI_CONTENT GREATER_THAN
   */
  yyval = PyObject_CallMethod(Bindings, "BaseDeclaration", "O", value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--BaseDecl(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 12: {
  /* from SPARQL.bgen, line 160
   * SelectQuery: SELECT VAR_REFERENCES WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOO", value_ptr[2],Py_None,value_ptr[3],value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 13: {
  /* from SPARQL.bgen, line 169
   * SelectQuery: SELECT VAR_REFERENCES DataSetClauseList WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOO", value_ptr[2],value_ptr[3],value_ptr[4],value_ptr[5]);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  break;
}
case 14: {
  /* from SPARQL.bgen, line 179
   * SelectQuery: SELECT DISTINCT VAR_REFERENCES WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOOi", value_ptr[3],Py_None,value_ptr[4],value_ptr[5],1);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  break;
}
case 15: {
  /* from SPARQL.bgen, line 189
   * SelectQuery: SELECT DISTINCT VAR_REFERENCES DataSetClauseList WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOOi", value_ptr[3],value_ptr[4],value_ptr[5],value_ptr[6],1);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  break;
}
case 17: {
  /* from SPARQL.bgen, line 208
   * VAR_REFERENCES: ASTERISK
   */
  yyval = Py_None;
  if (self->verbose) {
    fprintf(stderr, "--VAR_REFERENCES(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 18: {
  /* from SPARQL.bgen, line 218
   * VariableReferenceList: Var
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--VariableReferenceList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 19: {
  /* from SPARQL.bgen, line 226
   * VariableReferenceList: VariableReferenceList Var
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--VariableReferenceList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 20: {
  /* from SPARQL.bgen, line 240
   * IRIref: LESS_THAN Q_IRI_CONTENT GREATER_THAN
   */
  yyval = PyObject_CallMethod(IRIRef, "IRIRef", "O",value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--IRIref(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 22: {
  /* from SPARQL.bgen, line 257
   * QName: QNAME
   */
  yyval = PyObject_CallMethod(QName, "QName", "O",value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--QName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 23: {
  /* from SPARQL.bgen, line 263
   * QName: QNAME_NS
   */
  PyObject *str = PySequence_GetSlice(value_ptr[1], 0, PyString_GET_SIZE(value_ptr[1]) -1);
  yyval = PyObject_CallMethod(QName, "QNamePrefix", "O",str);
  Py_XDECREF(str);
  if (self->verbose) {
    fprintf(stderr, "--QName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 24: {
  /* from SPARQL.bgen, line 275
   * DataSetClauseList: DataSetClause
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--DataSetClauseList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 25: {
  /* from SPARQL.bgen, line 286
   * DataSetClauseList: DataSetClauseList DataSetClause
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--DataSetClauseList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 26: {
  /* from SPARQL.bgen, line 304
   * DataSetClause: FROM IRIref
   */
  yyval = PyObject_CallMethod(IRIRef, "RemoteGraph", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--DataSetClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 27: {
  /* from SPARQL.bgen, line 314
   * DataSetClause: FROM NAMED IRIref
   */
  yyval = PyObject_CallMethod(IRIRef, "NamedGraph", "O", value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--DataSetClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 28: {
  /* from SPARQL.bgen, line 330
   * WhereClause: WHERE GroupGraphPattern
   */
  yyval = PyObject_CallMethod(Query, "WhereClause", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--WhereClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 29: {
  /* from SPARQL.bgen, line 337
   * WhereClause: GroupGraphPattern
   */
  yyval = PyObject_CallMethod(Query, "WhereClause", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--WhereClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 30: {
  /* from SPARQL.bgen, line 349
   * SolutionModifier:
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "");
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 31: {
  /* from SPARQL.bgen, line 354
   * SolutionModifier: OrderClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "O",value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 32: {
  /* from SPARQL.bgen, line 360
   * SolutionModifier: OrderClause LimitClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OO",value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 33: {
  /* from SPARQL.bgen, line 367
   * SolutionModifier: OrderClause LimitClause OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",value_ptr[1],value_ptr[2],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 34: {
  /* from SPARQL.bgen, line 375
   * SolutionModifier: LimitClause OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",Py_None,value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 35: {
  /* from SPARQL.bgen, line 382
   * SolutionModifier: OrderClause OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",value_ptr[1],Py_None,value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 36: {
  /* from SPARQL.bgen, line 389
   * SolutionModifier: OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",Py_None,Py_None,value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 37: {
  /* from SPARQL.bgen, line 395
   * SolutionModifier: LimitClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",Py_None,value_ptr[1],Py_None);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 38: {
  /* from SPARQL.bgen, line 406
   * OrderClause: ORDER BY OrderConditionList
   */
  yyval = value_ptr[3];
  Py_INCREF(value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--OrderClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 39: {
  /* from SPARQL.bgen, line 419
   * OrderConditionList: OrderCondition
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--OrderConditionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 40: {
  /* from SPARQL.bgen, line 427
   * OrderConditionList: OrderConditionList OrderCondition
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--OrderConditionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 41: {
  /* from SPARQL.bgen, line 441
   * OrderCondition: ASC LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *t = PyObject_GetAttrString(SolutionModifier, "ASCENDING_ORDER");
  yyval = PyObject_CallMethod(SolutionModifier, "ParsedOrderConditionExpression", "OO",value_ptr[3],t);
  Py_XDECREF(t);
  if (self->verbose) {
    fprintf(stderr, "--OrderCondition(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 42: {
  /* from SPARQL.bgen, line 452
   * OrderCondition: DESC LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *t = PyObject_GetAttrString(SolutionModifier, "DESCENDING_ORDER");
  yyval = PyObject_CallMethod(SolutionModifier, "ParsedOrderConditionExpression", "OO",value_ptr[3],t);
  Py_XDECREF(t);
  if (self->verbose) {
    fprintf(stderr, "--OrderCondition(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 44: {
  /* from SPARQL.bgen, line 466
   * OrderCondition: LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *t = PyObject_GetAttrString(SolutionModifier, "UNSPECIFIED_ORDER");
  yyval = PyObject_CallMethod(SolutionModifier, "ParsedOrderConditionExpression", "OO",value_ptr[2],t);
  Py_XDECREF(t);
  if (self->verbose) {
    fprintf(stderr, "--OrderCondition(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 46: {
  /* from SPARQL.bgen, line 484
   * LimitClause: LIMIT NumericLiteral
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--LimitClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 47: {
  /* from SPARQL.bgen, line 497
   * OffsetClause: OFFSET NumericLiteral
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--OffsetClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 48: {
  /* from SPARQL.bgen, line 511
   * GroupGraphPattern: LEFT_CURLY GraphPattern RIGHT_CURLY
   */
  yyval = PyObject_CallMethod(GraphPattern, "ParsedGraphPattern", "O",value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--GroupGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 49: {
  /* from SPARQL.bgen, line 542
   * GraphPattern: FilteredBasicGraphPattern
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],Py_None));
  if (self->verbose) {
    fprintf(stderr, "--GraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 50: {
  /* from SPARQL.bgen, line 549
   * GraphPattern: FilteredBasicGraphPattern GraphPatternNotTriples GraphPattern
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],value_ptr[2]),value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--GraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 51: {
  /* from SPARQL.bgen, line 557
   * GraphPattern: FilteredBasicGraphPattern GraphPatternNotTriples DOT GraphPattern
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],value_ptr[2]),value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--GraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 52: {
  /* from SPARQL.bgen, line 610
   * GraphPatternNotTriples: OPTIONAL GroupGraphPattern
   */
  yyval = PyObject_CallMethod(GraphPattern, "ParsedOptionalGraphPattern", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--GraphPatternNotTriples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 53: {
  /* from SPARQL.bgen, line 617
   * GraphPatternNotTriples: GroupGraphPattern AlternativeGroupGraphPatterns
   */
  /*PyObject *altPatterns = PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],value_ptr[2]);*/
  yyval = PyObject_CallMethod(GraphPattern, "ParsedAlternativeGraphPattern", "OO", value_ptr[1],value_ptr[2]);
  /*Py_XDECREF(altPatterns);*/
  if (self->verbose) {
    fprintf(stderr, "--GraphPatternNotTriples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 54: {
  /* from SPARQL.bgen, line 657
   * AlternativeGroupGraphPatterns: UNION GroupGraphPattern
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--AlternativeGroupGraphPatterns(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 55: {
  /* from SPARQL.bgen, line 666
   * AlternativeGroupGraphPatterns: AlternativeGroupGraphPatterns UNION GroupGraphPattern
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--AlternativeGroupGraphPatterns(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 56: {
  /* from SPARQL.bgen, line 687
   * ConditionalOrExpression: ConditionalAndExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedConditionalAndExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalOrExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 57: {
  /* from SPARQL.bgen, line 693
   * ConditionalOrExpression: ConditionalAndExpression ConditionalAndExpressionList
   */
  yyval = PyObject_CallMethod(Expression, "ParsedConditionalAndExpressionList", "O", PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--ConditionalOrExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 58: {
  /* from SPARQL.bgen, line 705
   * ConditionalAndExpressionList: DOUBLE_PIPE ConditionalAndExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 59: {
  /* from SPARQL.bgen, line 714
   * ConditionalAndExpressionList: ConditionalAndExpressionList DOUBLE_PIPE ConditionalAndExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 60: {
  /* from SPARQL.bgen, line 729
   * ConditionalAndExpression: RelationalExpression ValueLogicalList
   */
  PyList_Append(value_ptr[2], value_ptr[1]);
  yyval = PyObject_CallMethod(Expression, "ParsedRelationalExpressionList", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 61: {
  /* from SPARQL.bgen, line 737
   * ConditionalAndExpression: RelationalExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedRelationalExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 62: {
  /* from SPARQL.bgen, line 747
   * ValueLogicalList: DOUBLE_AMPERSAND RelationalExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--ValueLogicalList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 63: {
  /* from SPARQL.bgen, line 756
   * ValueLogicalList: ValueLogicalList DOUBLE_AMPERSAND RelationalExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--ValueLogicalList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 65: {
  /* from SPARQL.bgen, line 784
   * RelationalExpression: AdditiveExpression EQUALITY_OP AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "EqualityOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 66: {
  /* from SPARQL.bgen, line 792
   * RelationalExpression: AdditiveExpression NOT_EQUAL AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "NotEqualOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 67: {
  /* from SPARQL.bgen, line 800
   * RelationalExpression: AdditiveExpression LESS_THAN AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "LessThanOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 68: {
  /* from SPARQL.bgen, line 808
   * RelationalExpression: AdditiveExpression GREATER_THAN AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "GreaterThanOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 69: {
  /* from SPARQL.bgen, line 816
   * RelationalExpression: AdditiveExpression LESS_THAN_EQUAL AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "LessThanOrEqualOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 70: {
  /* from SPARQL.bgen, line 824
   * RelationalExpression: AdditiveExpression GREATER_THAN_EQUAL AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "GreaterThanOrEqualOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 71: {
  /* from SPARQL.bgen, line 837
   * AdditiveExpression: MultiplicativeExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedAdditiveExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 72: {
  /* from SPARQL.bgen, line 843
   * AdditiveExpression: MultiplicativeExpression MultiplicativeExpressionList
   */
  yyval = PyObject_CallMethod(Expression, "ParsedAdditiveExpressionList", "O", PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 73: {
  /* from SPARQL.bgen, line 854
   * MultiplicativeExpressionList: PLUS MultiplicativeExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 74: {
  /* from SPARQL.bgen, line 863
   * MultiplicativeExpressionList: MINUS MultiplicativeExpression
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 75: {
  /* from SPARQL.bgen, line 872
   * MultiplicativeExpressionList: MultiplicativeExpressionList MINUS MultiplicativeExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 76: {
  /* from SPARQL.bgen, line 882
   * MultiplicativeExpressionList: MultiplicativeExpressionList PLUS MultiplicativeExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 77: {
  /* from SPARQL.bgen, line 897
   * MultiplicativeExpression: UnaryExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedMultiplicativeExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 78: {
  /* from SPARQL.bgen, line 903
   * MultiplicativeExpression: UnaryExpression UnaryExpressionList
   */
  yyval = PyObject_CallMethod(Expression, "ParsedMultiplicativeExpressionList", "O", PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 79: {
  /* from SPARQL.bgen, line 914
   * UnaryExpressionList: ASTERISK UnaryExpression
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 80: {
  /* from SPARQL.bgen, line 923
   * UnaryExpressionList: FORWARDSLASH UnaryExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 81: {
  /* from SPARQL.bgen, line 932
   * UnaryExpressionList: UnaryExpressionList ASTERISK UnaryExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 82: {
  /* from SPARQL.bgen, line 942
   * UnaryExpressionList: UnaryExpressionList FORWARDSLASH UnaryExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 83: {
  /* from SPARQL.bgen, line 957
   * UnaryExpression: BANG PrimaryExpression
   */
  yyval = PyObject_CallMethod(Operators, "LogicalNegation", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 84: {
  /* from SPARQL.bgen, line 964
   * UnaryExpression: PLUS PrimaryExpression
   */
  yyval = PyObject_CallMethod(Operators, "NumericPositive", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 85: {
  /* from SPARQL.bgen, line 971
   * UnaryExpression: MINUS PrimaryExpression
   */
  yyval = PyObject_CallMethod(Operators, "NumericNegative", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 87: {
  /* from SPARQL.bgen, line 998
   * BuiltInCall: STR LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "STR");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 88: {
  /* from SPARQL.bgen, line 1012
   * BuiltInCall: LANG LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "LANG");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 89: {
  /* from SPARQL.bgen, line 1026
   * BuiltInCall: LANGMATCHES LEFT_PAREN ConditionalOrExpression COMMA ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyList_SET_ITEM(args, 0, value_ptr[5]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "LANGMATCHES");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  break;
}
case 90: {
  /* from SPARQL.bgen, line 1043
   * BuiltInCall: DATATYPE LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "DATATYPE");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 91: {
  /* from SPARQL.bgen, line 1057
   * BuiltInCall: BOUND LEFT_PAREN Var RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  Py_INCREF(value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "BOUND");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 92: {
  /* from SPARQL.bgen, line 1072
   * BuiltInCall: isIRI LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isIRI");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 93: {
  /* from SPARQL.bgen, line 1086
   * BuiltInCall: isURI LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isURI");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 94: {
  /* from SPARQL.bgen, line 1100
   * BuiltInCall: isBLANK LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isBLANK");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 95: {
  /* from SPARQL.bgen, line 1114
   * BuiltInCall: isLITERAL LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isLITERAL");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 97: {
  /* from SPARQL.bgen, line 1136
   * RegexExpression: REGEX LEFT_PAREN ConditionalOrExpression COMMA ConditionalOrExpression RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(FunctionLibrary, "ParsedREGEXInvocation", "OO", value_ptr[3],value_ptr[5]);
  if (self->verbose) {
    fprintf(stderr, "--RegexExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  break;
}
case 98: {
  /* from SPARQL.bgen, line 1147
   * RegexExpression: REGEX LEFT_PAREN ConditionalOrExpression COMMA ConditionalOrExpression COMMA ConditionalOrExpression RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(FunctionLibrary, "ParsedREGEXInvocation", "OOO", value_ptr[3],value_ptr[5],value_ptr[7]);
  if (self->verbose) {
    fprintf(stderr, "--RegexExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[7], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[8], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  Py_DECREF(value_ptr[7]);
  Py_DECREF(value_ptr[8]);
  break;
}
case 99: {
  /* from SPARQL.bgen, line 1165
   * FunctionCall: IRIref LEFT_PAREN ArgumentList RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(FunctionLibrary, "FunctionCall", "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--FunctionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 100: {
  /* from SPARQL.bgen, line 1184
   * ArgumentList: NIL
   */
  yyval = PyList_New(0);
  if (self->verbose) {
    fprintf(stderr, "--ArgumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 101: {
  /* from SPARQL.bgen, line 1190
   * ArgumentList: ConditionalOrExpression
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ArgumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 102: {
  /* from SPARQL.bgen, line 1199
   * ArgumentList: ConditionalOrExpression COMMA ArgumentList
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--ArgumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 112: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 6
   * FilteredBasicGraphPattern:
   */
  yyval = PyList_New(0);
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 113: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 11
   * FilteredBasicGraphPattern: Triples
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 114: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 19
   * FilteredBasicGraphPattern: Triples Constraint DOT FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[4], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", value_ptr[1],value_ptr[2]));
  Py_INCREF(value_ptr[4]);
  yyval = value_ptr[4];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 115: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 30
   * FilteredBasicGraphPattern: Triples Constraint FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[3], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", value_ptr[1],value_ptr[2]));
  Py_INCREF(value_ptr[3]);
  yyval = value_ptr[3];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 116: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 40
   * FilteredBasicGraphPattern: Constraint DOT FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[3], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", Py_None,value_ptr[1]));
  Py_INCREF(value_ptr[3]);
  yyval = value_ptr[3];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 117: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 50
   * FilteredBasicGraphPattern: Constraint FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[2], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", Py_None,value_ptr[1]));
  Py_INCREF(value_ptr[2]);
  yyval = value_ptr[2];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 118: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 66
   * Constraint: FILTER LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(Filter, "ParsedExpressionFilter", "O", value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--Constraint(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 119: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 75
   * Constraint: FILTER BuiltInCall
   */
  yyval = PyObject_CallMethod(Filter, "ParsedFunctionFilter", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Constraint(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 120: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 82
   * Constraint: FILTER FunctionCall
   */
  yyval = PyObject_CallMethod(Filter, "ParsedFunctionFilter", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Constraint(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 121: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 99
   * Triples: Triples DOT TriplesSameSubject
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Triples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 123: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 113
   * Triples: TriplesSameSubject
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Triples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 124: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 139
   * TriplesSameSubject: Var PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 125: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 149
   * TriplesSameSubject: GraphTerm PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 126: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 159
   * TriplesSameSubject: LEFT_SQUARE PropertyListNotEmpty RIGHT_SQUARE PropertyList
   */
  yyval = PyObject_CallMethod(Resource, "TwiceReferencedBlankNode", "OO", value_ptr[2],value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 127: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 168
   * TriplesSameSubject: Collection PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 128: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 175
   * TriplesSameSubject: Collection
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 131: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 201
   * PropertyListNotEmpty: Verb ObjectList
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, PyObject_CallMethod(Triples, "PropertyValue", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--PropertyListNotEmpty(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 132: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 209
   * PropertyListNotEmpty: Verb ObjectList SEMICOLON PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", PyObject_CallMethod(Triples, "PropertyValue", "OO", value_ptr[1],value_ptr[2]),value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--PropertyListNotEmpty(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 133: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 218
   * PropertyListNotEmpty: Verb ObjectList SEMICOLON
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, PyObject_CallMethod(Triples, "PropertyValue", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--PropertyListNotEmpty(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 134: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 234
   * ObjectList: GraphNode
   */
         yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ObjectList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 135: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 245
   * ObjectList: ObjectList COMMA GraphNode
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--ObjectList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 141: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 292
   * Verb: A
   */
  yyval = PyObject_GetAttrString(RDF, "type");
  if (self->verbose) {
    fprintf(stderr, "--Verb(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 143: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 313
   * TriplesNode: LEFT_SQUARE PropertyList RIGHT_SQUARE
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", Py_None,value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesNode(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 144: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 328
   * Collection: LEFT_PAREN GraphNodeList RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(Resource, "ParsedCollection", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Collection(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 145: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 340
   * GraphNodeList: GraphNode
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--GraphNodeList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 146: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 348
   * GraphNodeList: GraphNodeList GraphNode
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--GraphNodeList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 147: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 362
   * Var: VARNAME
   */
  yyval = PyObject_CallMethod(rdflib, "Variable", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Var(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 152: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 394
   * GraphTerm: MINUS NumericLiteral
   */
  PyObject *negNum = PyNumber_Negative(value_ptr[2]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", negNum);
  Py_XDECREF(negNum);
  if (self->verbose) {
    fprintf(stderr, "--GraphTerm(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 156: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 425
   * NumericLiteral: INTEGER
   */
         PyObject *num = PyNumber_Int(value_ptr[1]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", num);
         Py_XDECREF(num);
  if (self->verbose) {
    fprintf(stderr, "--NumericLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 157: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 437
   * NumericLiteral: DECIMAL
   */
         PyObject *num = PyNumber_Float(value_ptr[1]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", num);
         Py_XDECREF(num);
  if (self->verbose) {
    fprintf(stderr, "--NumericLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 158: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 449
   * NumericLiteral: DOUBLE
   */
         PyObject *num = PyNumber_Float(value_ptr[1]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", num);
         Py_XDECREF(num);
  if (self->verbose) {
    fprintf(stderr, "--NumericLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 160: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 471
   * RDFLiteral: String LANGTAG
   */
  PyObject *lang = PySequence_GetSlice(value_ptr[2], 1, PyString_GET_SIZE(value_ptr[2]));
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", value_ptr[1],lang);
  Py_XDECREF(lang);
  if (self->verbose) {
    fprintf(stderr, "--RDFLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 161: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 480
   * RDFLiteral: String DOUBLE_HAT IRIref
   */
  yyval = PyObject_CallMethod(rdflib, "Literal", "OOO", value_ptr[1],Py_None,value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RDFLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 164: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 507
   * String: STRING_LITERAL_DELIMETER_1 STRING_LITERAL1 STRING_LITERAL_DELIMETER_1
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 165: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 515
   * String: STRING_LITERAL_DELIMETER_3 STRING_LITERAL2 STRING_LITERAL_DELIMETER_3
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 166: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 523
   * String: STRING_LITERAL_DELIMETER_2 STRING_LITERAL_LONG1 STRING_LITERAL_DELIMETER_2
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 167: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 531
   * String: STRING_LITERAL_DELIMETER_4 STRING_LITERAL_LONG2 STRING_LITERAL_DELIMETER_4
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 168: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 544
   * BlankNode: ANON
   */
  yyval = PyObject_CallMethod(rdflib, "BNode","");
  if (self->verbose) {
    fprintf(stderr, "--BlankNode(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 169: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 550
   * BlankNode: BLANK_NODE_LABEL
   */
  yyval = PyObject_CallMethod(rdflib, "BNode", "O",value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--BlankNode(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);


      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    } /* if (yyn == YYFLAG) */

    /* Not known => get a lookahead token if don't already have one. */

    /* yychar is either YYEMPTY, YYEOF or a valid token in external form */
    if (yychar == YYEMPTY) {
      TRACE("Reading a token: ");
      yychar = parser_yylex(self, lexer, &yylval);
    }

    /* Convert token to internal form (in yychar1) for indexing tables with */

    if (yychar <= 0) {
      if (yychar == YYERROR) {
        lexer_free(lexer);
        return NULL;
      }
      /* This means end-of-input. */
      yychar1 = 0;
      TRACE("Now at end of input.\n");
    } else {
      yychar1 = YYTRANSLATE(yychar);
      TRACE("Next token is %d (%s)\n", yychar, token_names[yychar1]);
      yyn += yychar1;
    }
    if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1) {
      /* comes here after end of input */
      yyn = default_action[yystate];
      if (yyn == 0) {
        return report_error(yystate, NULL, lexer);
      }

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 1: {
  /* from SPARQL.bgen, line 42
   * Query: Prolog QueryTypes
   */
  yyval = PyObject_CallMethod(Query, "Query", "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Query(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 2: {
  /* from SPARQL.bgen, line 49
   * Query: QueryTypes
   */
  yyval = PyObject_CallMethod(Query, "Query", "OO", Py_None, value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Query(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 3: {
  /* from SPARQL.bgen, line 59
   * QueryTypes: SelectQuery
   */
  yyval = value_ptr[1];
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--QueryTypes(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 4: {
  /* from SPARQL.bgen, line 80
   * Prolog: BaseDecl OptionalPrefixDeclList
   */
  yyval = PyObject_CallMethod(Query, "Prolog", "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Prolog(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 5: {
  /* from SPARQL.bgen, line 87
   * Prolog: OptionalPrefixDeclList
   */
  yyval = PyObject_CallMethod(Query, "Prolog", "OO", Py_None, value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Prolog(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 8: {
  /* from SPARQL.bgen, line 109
   * PrefixDeclList: PrefixDecl
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrefixDeclList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 9: {
  /* from SPARQL.bgen, line 117
   * PrefixDeclList: PrefixDeclList PrefixDecl
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--PrefixDeclList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 10: {
  /* from SPARQL.bgen, line 131
   * PrefixDecl: PREFIX QNAME_NS LESS_THAN Q_IRI_CONTENT GREATER_THAN
   */
  yyval = PyObject_CallMethod(Bindings, "PrefixDeclaration", "OO", value_ptr[2],value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--PrefixDecl(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  break;
}
case 11: {
  /* from SPARQL.bgen, line 146
   * BaseDecl: BASE LESS_THAN Q_IRI_CONTENT GREATER_THAN
   */
  yyval = PyObject_CallMethod(Bindings, "BaseDeclaration", "O", value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--BaseDecl(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 12: {
  /* from SPARQL.bgen, line 160
   * SelectQuery: SELECT VAR_REFERENCES WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOO", value_ptr[2],Py_None,value_ptr[3],value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 13: {
  /* from SPARQL.bgen, line 169
   * SelectQuery: SELECT VAR_REFERENCES DataSetClauseList WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOO", value_ptr[2],value_ptr[3],value_ptr[4],value_ptr[5]);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  break;
}
case 14: {
  /* from SPARQL.bgen, line 179
   * SelectQuery: SELECT DISTINCT VAR_REFERENCES WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOOi", value_ptr[3],Py_None,value_ptr[4],value_ptr[5],1);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  break;
}
case 15: {
  /* from SPARQL.bgen, line 189
   * SelectQuery: SELECT DISTINCT VAR_REFERENCES DataSetClauseList WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOOi", value_ptr[3],value_ptr[4],value_ptr[5],value_ptr[6],1);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  break;
}
case 17: {
  /* from SPARQL.bgen, line 208
   * VAR_REFERENCES: ASTERISK
   */
  yyval = Py_None;
  if (self->verbose) {
    fprintf(stderr, "--VAR_REFERENCES(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 18: {
  /* from SPARQL.bgen, line 218
   * VariableReferenceList: Var
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--VariableReferenceList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 19: {
  /* from SPARQL.bgen, line 226
   * VariableReferenceList: VariableReferenceList Var
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--VariableReferenceList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 20: {
  /* from SPARQL.bgen, line 240
   * IRIref: LESS_THAN Q_IRI_CONTENT GREATER_THAN
   */
  yyval = PyObject_CallMethod(IRIRef, "IRIRef", "O",value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--IRIref(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 22: {
  /* from SPARQL.bgen, line 257
   * QName: QNAME
   */
  yyval = PyObject_CallMethod(QName, "QName", "O",value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--QName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 23: {
  /* from SPARQL.bgen, line 263
   * QName: QNAME_NS
   */
  PyObject *str = PySequence_GetSlice(value_ptr[1], 0, PyString_GET_SIZE(value_ptr[1]) -1);
  yyval = PyObject_CallMethod(QName, "QNamePrefix", "O",str);
  Py_XDECREF(str);
  if (self->verbose) {
    fprintf(stderr, "--QName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 24: {
  /* from SPARQL.bgen, line 275
   * DataSetClauseList: DataSetClause
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--DataSetClauseList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 25: {
  /* from SPARQL.bgen, line 286
   * DataSetClauseList: DataSetClauseList DataSetClause
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--DataSetClauseList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 26: {
  /* from SPARQL.bgen, line 304
   * DataSetClause: FROM IRIref
   */
  yyval = PyObject_CallMethod(IRIRef, "RemoteGraph", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--DataSetClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 27: {
  /* from SPARQL.bgen, line 314
   * DataSetClause: FROM NAMED IRIref
   */
  yyval = PyObject_CallMethod(IRIRef, "NamedGraph", "O", value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--DataSetClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 28: {
  /* from SPARQL.bgen, line 330
   * WhereClause: WHERE GroupGraphPattern
   */
  yyval = PyObject_CallMethod(Query, "WhereClause", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--WhereClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 29: {
  /* from SPARQL.bgen, line 337
   * WhereClause: GroupGraphPattern
   */
  yyval = PyObject_CallMethod(Query, "WhereClause", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--WhereClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 30: {
  /* from SPARQL.bgen, line 349
   * SolutionModifier:
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "");
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 31: {
  /* from SPARQL.bgen, line 354
   * SolutionModifier: OrderClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "O",value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 32: {
  /* from SPARQL.bgen, line 360
   * SolutionModifier: OrderClause LimitClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OO",value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 33: {
  /* from SPARQL.bgen, line 367
   * SolutionModifier: OrderClause LimitClause OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",value_ptr[1],value_ptr[2],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 34: {
  /* from SPARQL.bgen, line 375
   * SolutionModifier: LimitClause OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",Py_None,value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 35: {
  /* from SPARQL.bgen, line 382
   * SolutionModifier: OrderClause OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",value_ptr[1],Py_None,value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 36: {
  /* from SPARQL.bgen, line 389
   * SolutionModifier: OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",Py_None,Py_None,value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 37: {
  /* from SPARQL.bgen, line 395
   * SolutionModifier: LimitClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",Py_None,value_ptr[1],Py_None);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 38: {
  /* from SPARQL.bgen, line 406
   * OrderClause: ORDER BY OrderConditionList
   */
  yyval = value_ptr[3];
  Py_INCREF(value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--OrderClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 39: {
  /* from SPARQL.bgen, line 419
   * OrderConditionList: OrderCondition
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--OrderConditionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 40: {
  /* from SPARQL.bgen, line 427
   * OrderConditionList: OrderConditionList OrderCondition
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--OrderConditionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 41: {
  /* from SPARQL.bgen, line 441
   * OrderCondition: ASC LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *t = PyObject_GetAttrString(SolutionModifier, "ASCENDING_ORDER");
  yyval = PyObject_CallMethod(SolutionModifier, "ParsedOrderConditionExpression", "OO",value_ptr[3],t);
  Py_XDECREF(t);
  if (self->verbose) {
    fprintf(stderr, "--OrderCondition(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 42: {
  /* from SPARQL.bgen, line 452
   * OrderCondition: DESC LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *t = PyObject_GetAttrString(SolutionModifier, "DESCENDING_ORDER");
  yyval = PyObject_CallMethod(SolutionModifier, "ParsedOrderConditionExpression", "OO",value_ptr[3],t);
  Py_XDECREF(t);
  if (self->verbose) {
    fprintf(stderr, "--OrderCondition(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 44: {
  /* from SPARQL.bgen, line 466
   * OrderCondition: LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *t = PyObject_GetAttrString(SolutionModifier, "UNSPECIFIED_ORDER");
  yyval = PyObject_CallMethod(SolutionModifier, "ParsedOrderConditionExpression", "OO",value_ptr[2],t);
  Py_XDECREF(t);
  if (self->verbose) {
    fprintf(stderr, "--OrderCondition(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 46: {
  /* from SPARQL.bgen, line 484
   * LimitClause: LIMIT NumericLiteral
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--LimitClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 47: {
  /* from SPARQL.bgen, line 497
   * OffsetClause: OFFSET NumericLiteral
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--OffsetClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 48: {
  /* from SPARQL.bgen, line 511
   * GroupGraphPattern: LEFT_CURLY GraphPattern RIGHT_CURLY
   */
  yyval = PyObject_CallMethod(GraphPattern, "ParsedGraphPattern", "O",value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--GroupGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 49: {
  /* from SPARQL.bgen, line 542
   * GraphPattern: FilteredBasicGraphPattern
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],Py_None));
  if (self->verbose) {
    fprintf(stderr, "--GraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 50: {
  /* from SPARQL.bgen, line 549
   * GraphPattern: FilteredBasicGraphPattern GraphPatternNotTriples GraphPattern
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],value_ptr[2]),value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--GraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 51: {
  /* from SPARQL.bgen, line 557
   * GraphPattern: FilteredBasicGraphPattern GraphPatternNotTriples DOT GraphPattern
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],value_ptr[2]),value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--GraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 52: {
  /* from SPARQL.bgen, line 610
   * GraphPatternNotTriples: OPTIONAL GroupGraphPattern
   */
  yyval = PyObject_CallMethod(GraphPattern, "ParsedOptionalGraphPattern", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--GraphPatternNotTriples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 53: {
  /* from SPARQL.bgen, line 617
   * GraphPatternNotTriples: GroupGraphPattern AlternativeGroupGraphPatterns
   */
  /*PyObject *altPatterns = PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],value_ptr[2]);*/
  yyval = PyObject_CallMethod(GraphPattern, "ParsedAlternativeGraphPattern", "OO", value_ptr[1],value_ptr[2]);
  /*Py_XDECREF(altPatterns);*/
  if (self->verbose) {
    fprintf(stderr, "--GraphPatternNotTriples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 54: {
  /* from SPARQL.bgen, line 657
   * AlternativeGroupGraphPatterns: UNION GroupGraphPattern
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--AlternativeGroupGraphPatterns(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 55: {
  /* from SPARQL.bgen, line 666
   * AlternativeGroupGraphPatterns: AlternativeGroupGraphPatterns UNION GroupGraphPattern
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--AlternativeGroupGraphPatterns(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 56: {
  /* from SPARQL.bgen, line 687
   * ConditionalOrExpression: ConditionalAndExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedConditionalAndExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalOrExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 57: {
  /* from SPARQL.bgen, line 693
   * ConditionalOrExpression: ConditionalAndExpression ConditionalAndExpressionList
   */
  yyval = PyObject_CallMethod(Expression, "ParsedConditionalAndExpressionList", "O", PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--ConditionalOrExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 58: {
  /* from SPARQL.bgen, line 705
   * ConditionalAndExpressionList: DOUBLE_PIPE ConditionalAndExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 59: {
  /* from SPARQL.bgen, line 714
   * ConditionalAndExpressionList: ConditionalAndExpressionList DOUBLE_PIPE ConditionalAndExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 60: {
  /* from SPARQL.bgen, line 729
   * ConditionalAndExpression: RelationalExpression ValueLogicalList
   */
  PyList_Append(value_ptr[2], value_ptr[1]);
  yyval = PyObject_CallMethod(Expression, "ParsedRelationalExpressionList", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 61: {
  /* from SPARQL.bgen, line 737
   * ConditionalAndExpression: RelationalExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedRelationalExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 62: {
  /* from SPARQL.bgen, line 747
   * ValueLogicalList: DOUBLE_AMPERSAND RelationalExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--ValueLogicalList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 63: {
  /* from SPARQL.bgen, line 756
   * ValueLogicalList: ValueLogicalList DOUBLE_AMPERSAND RelationalExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--ValueLogicalList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 65: {
  /* from SPARQL.bgen, line 784
   * RelationalExpression: AdditiveExpression EQUALITY_OP AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "EqualityOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 66: {
  /* from SPARQL.bgen, line 792
   * RelationalExpression: AdditiveExpression NOT_EQUAL AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "NotEqualOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 67: {
  /* from SPARQL.bgen, line 800
   * RelationalExpression: AdditiveExpression LESS_THAN AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "LessThanOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 68: {
  /* from SPARQL.bgen, line 808
   * RelationalExpression: AdditiveExpression GREATER_THAN AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "GreaterThanOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 69: {
  /* from SPARQL.bgen, line 816
   * RelationalExpression: AdditiveExpression LESS_THAN_EQUAL AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "LessThanOrEqualOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 70: {
  /* from SPARQL.bgen, line 824
   * RelationalExpression: AdditiveExpression GREATER_THAN_EQUAL AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "GreaterThanOrEqualOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 71: {
  /* from SPARQL.bgen, line 837
   * AdditiveExpression: MultiplicativeExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedAdditiveExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 72: {
  /* from SPARQL.bgen, line 843
   * AdditiveExpression: MultiplicativeExpression MultiplicativeExpressionList
   */
  yyval = PyObject_CallMethod(Expression, "ParsedAdditiveExpressionList", "O", PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 73: {
  /* from SPARQL.bgen, line 854
   * MultiplicativeExpressionList: PLUS MultiplicativeExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 74: {
  /* from SPARQL.bgen, line 863
   * MultiplicativeExpressionList: MINUS MultiplicativeExpression
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 75: {
  /* from SPARQL.bgen, line 872
   * MultiplicativeExpressionList: MultiplicativeExpressionList MINUS MultiplicativeExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 76: {
  /* from SPARQL.bgen, line 882
   * MultiplicativeExpressionList: MultiplicativeExpressionList PLUS MultiplicativeExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 77: {
  /* from SPARQL.bgen, line 897
   * MultiplicativeExpression: UnaryExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedMultiplicativeExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 78: {
  /* from SPARQL.bgen, line 903
   * MultiplicativeExpression: UnaryExpression UnaryExpressionList
   */
  yyval = PyObject_CallMethod(Expression, "ParsedMultiplicativeExpressionList", "O", PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 79: {
  /* from SPARQL.bgen, line 914
   * UnaryExpressionList: ASTERISK UnaryExpression
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 80: {
  /* from SPARQL.bgen, line 923
   * UnaryExpressionList: FORWARDSLASH UnaryExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 81: {
  /* from SPARQL.bgen, line 932
   * UnaryExpressionList: UnaryExpressionList ASTERISK UnaryExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 82: {
  /* from SPARQL.bgen, line 942
   * UnaryExpressionList: UnaryExpressionList FORWARDSLASH UnaryExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 83: {
  /* from SPARQL.bgen, line 957
   * UnaryExpression: BANG PrimaryExpression
   */
  yyval = PyObject_CallMethod(Operators, "LogicalNegation", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 84: {
  /* from SPARQL.bgen, line 964
   * UnaryExpression: PLUS PrimaryExpression
   */
  yyval = PyObject_CallMethod(Operators, "NumericPositive", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 85: {
  /* from SPARQL.bgen, line 971
   * UnaryExpression: MINUS PrimaryExpression
   */
  yyval = PyObject_CallMethod(Operators, "NumericNegative", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 87: {
  /* from SPARQL.bgen, line 998
   * BuiltInCall: STR LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "STR");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 88: {
  /* from SPARQL.bgen, line 1012
   * BuiltInCall: LANG LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "LANG");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 89: {
  /* from SPARQL.bgen, line 1026
   * BuiltInCall: LANGMATCHES LEFT_PAREN ConditionalOrExpression COMMA ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyList_SET_ITEM(args, 0, value_ptr[5]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "LANGMATCHES");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  break;
}
case 90: {
  /* from SPARQL.bgen, line 1043
   * BuiltInCall: DATATYPE LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "DATATYPE");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 91: {
  /* from SPARQL.bgen, line 1057
   * BuiltInCall: BOUND LEFT_PAREN Var RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  Py_INCREF(value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "BOUND");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 92: {
  /* from SPARQL.bgen, line 1072
   * BuiltInCall: isIRI LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isIRI");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 93: {
  /* from SPARQL.bgen, line 1086
   * BuiltInCall: isURI LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isURI");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 94: {
  /* from SPARQL.bgen, line 1100
   * BuiltInCall: isBLANK LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isBLANK");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 95: {
  /* from SPARQL.bgen, line 1114
   * BuiltInCall: isLITERAL LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isLITERAL");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 97: {
  /* from SPARQL.bgen, line 1136
   * RegexExpression: REGEX LEFT_PAREN ConditionalOrExpression COMMA ConditionalOrExpression RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(FunctionLibrary, "ParsedREGEXInvocation", "OO", value_ptr[3],value_ptr[5]);
  if (self->verbose) {
    fprintf(stderr, "--RegexExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  break;
}
case 98: {
  /* from SPARQL.bgen, line 1147
   * RegexExpression: REGEX LEFT_PAREN ConditionalOrExpression COMMA ConditionalOrExpression COMMA ConditionalOrExpression RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(FunctionLibrary, "ParsedREGEXInvocation", "OOO", value_ptr[3],value_ptr[5],value_ptr[7]);
  if (self->verbose) {
    fprintf(stderr, "--RegexExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[7], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[8], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  Py_DECREF(value_ptr[7]);
  Py_DECREF(value_ptr[8]);
  break;
}
case 99: {
  /* from SPARQL.bgen, line 1165
   * FunctionCall: IRIref LEFT_PAREN ArgumentList RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(FunctionLibrary, "FunctionCall", "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--FunctionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 100: {
  /* from SPARQL.bgen, line 1184
   * ArgumentList: NIL
   */
  yyval = PyList_New(0);
  if (self->verbose) {
    fprintf(stderr, "--ArgumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 101: {
  /* from SPARQL.bgen, line 1190
   * ArgumentList: ConditionalOrExpression
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ArgumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 102: {
  /* from SPARQL.bgen, line 1199
   * ArgumentList: ConditionalOrExpression COMMA ArgumentList
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--ArgumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 112: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 6
   * FilteredBasicGraphPattern:
   */
  yyval = PyList_New(0);
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 113: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 11
   * FilteredBasicGraphPattern: Triples
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 114: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 19
   * FilteredBasicGraphPattern: Triples Constraint DOT FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[4], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", value_ptr[1],value_ptr[2]));
  Py_INCREF(value_ptr[4]);
  yyval = value_ptr[4];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 115: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 30
   * FilteredBasicGraphPattern: Triples Constraint FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[3], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", value_ptr[1],value_ptr[2]));
  Py_INCREF(value_ptr[3]);
  yyval = value_ptr[3];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 116: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 40
   * FilteredBasicGraphPattern: Constraint DOT FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[3], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", Py_None,value_ptr[1]));
  Py_INCREF(value_ptr[3]);
  yyval = value_ptr[3];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 117: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 50
   * FilteredBasicGraphPattern: Constraint FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[2], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", Py_None,value_ptr[1]));
  Py_INCREF(value_ptr[2]);
  yyval = value_ptr[2];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 118: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 66
   * Constraint: FILTER LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(Filter, "ParsedExpressionFilter", "O", value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--Constraint(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 119: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 75
   * Constraint: FILTER BuiltInCall
   */
  yyval = PyObject_CallMethod(Filter, "ParsedFunctionFilter", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Constraint(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 120: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 82
   * Constraint: FILTER FunctionCall
   */
  yyval = PyObject_CallMethod(Filter, "ParsedFunctionFilter", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Constraint(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 121: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 99
   * Triples: Triples DOT TriplesSameSubject
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Triples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 123: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 113
   * Triples: TriplesSameSubject
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Triples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 124: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 139
   * TriplesSameSubject: Var PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 125: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 149
   * TriplesSameSubject: GraphTerm PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 126: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 159
   * TriplesSameSubject: LEFT_SQUARE PropertyListNotEmpty RIGHT_SQUARE PropertyList
   */
  yyval = PyObject_CallMethod(Resource, "TwiceReferencedBlankNode", "OO", value_ptr[2],value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 127: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 168
   * TriplesSameSubject: Collection PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 128: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 175
   * TriplesSameSubject: Collection
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 131: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 201
   * PropertyListNotEmpty: Verb ObjectList
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, PyObject_CallMethod(Triples, "PropertyValue", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--PropertyListNotEmpty(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 132: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 209
   * PropertyListNotEmpty: Verb ObjectList SEMICOLON PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", PyObject_CallMethod(Triples, "PropertyValue", "OO", value_ptr[1],value_ptr[2]),value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--PropertyListNotEmpty(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 133: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 218
   * PropertyListNotEmpty: Verb ObjectList SEMICOLON
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, PyObject_CallMethod(Triples, "PropertyValue", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--PropertyListNotEmpty(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 134: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 234
   * ObjectList: GraphNode
   */
         yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ObjectList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 135: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 245
   * ObjectList: ObjectList COMMA GraphNode
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--ObjectList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 141: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 292
   * Verb: A
   */
  yyval = PyObject_GetAttrString(RDF, "type");
  if (self->verbose) {
    fprintf(stderr, "--Verb(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 143: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 313
   * TriplesNode: LEFT_SQUARE PropertyList RIGHT_SQUARE
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", Py_None,value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesNode(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 144: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 328
   * Collection: LEFT_PAREN GraphNodeList RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(Resource, "ParsedCollection", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Collection(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 145: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 340
   * GraphNodeList: GraphNode
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--GraphNodeList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 146: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 348
   * GraphNodeList: GraphNodeList GraphNode
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--GraphNodeList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 147: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 362
   * Var: VARNAME
   */
  yyval = PyObject_CallMethod(rdflib, "Variable", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Var(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 152: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 394
   * GraphTerm: MINUS NumericLiteral
   */
  PyObject *negNum = PyNumber_Negative(value_ptr[2]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", negNum);
  Py_XDECREF(negNum);
  if (self->verbose) {
    fprintf(stderr, "--GraphTerm(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 156: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 425
   * NumericLiteral: INTEGER
   */
         PyObject *num = PyNumber_Int(value_ptr[1]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", num);
         Py_XDECREF(num);
  if (self->verbose) {
    fprintf(stderr, "--NumericLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 157: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 437
   * NumericLiteral: DECIMAL
   */
         PyObject *num = PyNumber_Float(value_ptr[1]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", num);
         Py_XDECREF(num);
  if (self->verbose) {
    fprintf(stderr, "--NumericLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 158: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 449
   * NumericLiteral: DOUBLE
   */
         PyObject *num = PyNumber_Float(value_ptr[1]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", num);
         Py_XDECREF(num);
  if (self->verbose) {
    fprintf(stderr, "--NumericLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 160: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 471
   * RDFLiteral: String LANGTAG
   */
  PyObject *lang = PySequence_GetSlice(value_ptr[2], 1, PyString_GET_SIZE(value_ptr[2]));
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", value_ptr[1],lang);
  Py_XDECREF(lang);
  if (self->verbose) {
    fprintf(stderr, "--RDFLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 161: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 480
   * RDFLiteral: String DOUBLE_HAT IRIref
   */
  yyval = PyObject_CallMethod(rdflib, "Literal", "OOO", value_ptr[1],Py_None,value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RDFLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 164: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 507
   * String: STRING_LITERAL_DELIMETER_1 STRING_LITERAL1 STRING_LITERAL_DELIMETER_1
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 165: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 515
   * String: STRING_LITERAL_DELIMETER_3 STRING_LITERAL2 STRING_LITERAL_DELIMETER_3
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 166: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 523
   * String: STRING_LITERAL_DELIMETER_2 STRING_LITERAL_LONG1 STRING_LITERAL_DELIMETER_2
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 167: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 531
   * String: STRING_LITERAL_DELIMETER_4 STRING_LITERAL_LONG2 STRING_LITERAL_DELIMETER_4
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 168: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 544
   * BlankNode: ANON
   */
  yyval = PyObject_CallMethod(rdflib, "BNode","");
  if (self->verbose) {
    fprintf(stderr, "--BlankNode(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 169: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 550
   * BlankNode: BLANK_NODE_LABEL
   */
  yyval = PyObject_CallMethod(rdflib, "BNode", "O",value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--BlankNode(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);

      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    }

    yyn = yytable[yyn];

    /* yyn is what to do for this token type in this state.
       Negative => reduce, -yyn is rule number.
       Positive => shift, yyn is new state.
         New state is final state => don't bother to shift
         just return success.
       0, or max negative number => error. */

    if (yyn > YYFLAG && yyn < 0) {
      yyn = -yyn;

      /* Do a reduction. yyn is the number of a rule to reduce with. */
      if (self->verbose) print_reduce(yyn);

      yylen = rhs_size[yyn];
      state_ptr -= yylen;
      value_ptr -= yylen;
      if (yylen > 0) yyval = value_ptr[1];

      /* Action routines */
      switch (yyn) {
case 1: {
  /* from SPARQL.bgen, line 42
   * Query: Prolog QueryTypes
   */
  yyval = PyObject_CallMethod(Query, "Query", "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Query(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 2: {
  /* from SPARQL.bgen, line 49
   * Query: QueryTypes
   */
  yyval = PyObject_CallMethod(Query, "Query", "OO", Py_None, value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Query(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 3: {
  /* from SPARQL.bgen, line 59
   * QueryTypes: SelectQuery
   */
  yyval = value_ptr[1];
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--QueryTypes(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 4: {
  /* from SPARQL.bgen, line 80
   * Prolog: BaseDecl OptionalPrefixDeclList
   */
  yyval = PyObject_CallMethod(Query, "Prolog", "OO", value_ptr[1], value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Prolog(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 5: {
  /* from SPARQL.bgen, line 87
   * Prolog: OptionalPrefixDeclList
   */
  yyval = PyObject_CallMethod(Query, "Prolog", "OO", Py_None, value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Prolog(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 8: {
  /* from SPARQL.bgen, line 109
   * PrefixDeclList: PrefixDecl
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--PrefixDeclList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 9: {
  /* from SPARQL.bgen, line 117
   * PrefixDeclList: PrefixDeclList PrefixDecl
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--PrefixDeclList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 10: {
  /* from SPARQL.bgen, line 131
   * PrefixDecl: PREFIX QNAME_NS LESS_THAN Q_IRI_CONTENT GREATER_THAN
   */
  yyval = PyObject_CallMethod(Bindings, "PrefixDeclaration", "OO", value_ptr[2],value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--PrefixDecl(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  break;
}
case 11: {
  /* from SPARQL.bgen, line 146
   * BaseDecl: BASE LESS_THAN Q_IRI_CONTENT GREATER_THAN
   */
  yyval = PyObject_CallMethod(Bindings, "BaseDeclaration", "O", value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--BaseDecl(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 12: {
  /* from SPARQL.bgen, line 160
   * SelectQuery: SELECT VAR_REFERENCES WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOO", value_ptr[2],Py_None,value_ptr[3],value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 13: {
  /* from SPARQL.bgen, line 169
   * SelectQuery: SELECT VAR_REFERENCES DataSetClauseList WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOO", value_ptr[2],value_ptr[3],value_ptr[4],value_ptr[5]);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  break;
}
case 14: {
  /* from SPARQL.bgen, line 179
   * SelectQuery: SELECT DISTINCT VAR_REFERENCES WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOOi", value_ptr[3],Py_None,value_ptr[4],value_ptr[5],1);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  break;
}
case 15: {
  /* from SPARQL.bgen, line 189
   * SelectQuery: SELECT DISTINCT VAR_REFERENCES DataSetClauseList WhereClause SolutionModifier
   */
  yyval = PyObject_CallMethod(Query, "SelectQuery", "OOOOi", value_ptr[3],value_ptr[4],value_ptr[5],value_ptr[6],1);
  if (self->verbose) {
    fprintf(stderr, "--SelectQuery(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  break;
}
case 17: {
  /* from SPARQL.bgen, line 208
   * VAR_REFERENCES: ASTERISK
   */
  yyval = Py_None;
  if (self->verbose) {
    fprintf(stderr, "--VAR_REFERENCES(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 18: {
  /* from SPARQL.bgen, line 218
   * VariableReferenceList: Var
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--VariableReferenceList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 19: {
  /* from SPARQL.bgen, line 226
   * VariableReferenceList: VariableReferenceList Var
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--VariableReferenceList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 20: {
  /* from SPARQL.bgen, line 240
   * IRIref: LESS_THAN Q_IRI_CONTENT GREATER_THAN
   */
  yyval = PyObject_CallMethod(IRIRef, "IRIRef", "O",value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--IRIref(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 22: {
  /* from SPARQL.bgen, line 257
   * QName: QNAME
   */
  yyval = PyObject_CallMethod(QName, "QName", "O",value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--QName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 23: {
  /* from SPARQL.bgen, line 263
   * QName: QNAME_NS
   */
  PyObject *str = PySequence_GetSlice(value_ptr[1], 0, PyString_GET_SIZE(value_ptr[1]) -1);
  yyval = PyObject_CallMethod(QName, "QNamePrefix", "O",str);
  Py_XDECREF(str);
  if (self->verbose) {
    fprintf(stderr, "--QName(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 24: {
  /* from SPARQL.bgen, line 275
   * DataSetClauseList: DataSetClause
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--DataSetClauseList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 25: {
  /* from SPARQL.bgen, line 286
   * DataSetClauseList: DataSetClauseList DataSetClause
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--DataSetClauseList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 26: {
  /* from SPARQL.bgen, line 304
   * DataSetClause: FROM IRIref
   */
  yyval = PyObject_CallMethod(IRIRef, "RemoteGraph", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--DataSetClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 27: {
  /* from SPARQL.bgen, line 314
   * DataSetClause: FROM NAMED IRIref
   */
  yyval = PyObject_CallMethod(IRIRef, "NamedGraph", "O", value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--DataSetClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 28: {
  /* from SPARQL.bgen, line 330
   * WhereClause: WHERE GroupGraphPattern
   */
  yyval = PyObject_CallMethod(Query, "WhereClause", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--WhereClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 29: {
  /* from SPARQL.bgen, line 337
   * WhereClause: GroupGraphPattern
   */
  yyval = PyObject_CallMethod(Query, "WhereClause", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--WhereClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 30: {
  /* from SPARQL.bgen, line 349
   * SolutionModifier:
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "");
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 31: {
  /* from SPARQL.bgen, line 354
   * SolutionModifier: OrderClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "O",value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 32: {
  /* from SPARQL.bgen, line 360
   * SolutionModifier: OrderClause LimitClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OO",value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 33: {
  /* from SPARQL.bgen, line 367
   * SolutionModifier: OrderClause LimitClause OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",value_ptr[1],value_ptr[2],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 34: {
  /* from SPARQL.bgen, line 375
   * SolutionModifier: LimitClause OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",Py_None,value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 35: {
  /* from SPARQL.bgen, line 382
   * SolutionModifier: OrderClause OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",value_ptr[1],Py_None,value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 36: {
  /* from SPARQL.bgen, line 389
   * SolutionModifier: OffsetClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",Py_None,Py_None,value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 37: {
  /* from SPARQL.bgen, line 395
   * SolutionModifier: LimitClause
   */
  yyval = PyObject_CallMethod(SolutionModifier, "SolutionModifier", "OOO",Py_None,value_ptr[1],Py_None);
  if (self->verbose) {
    fprintf(stderr, "--SolutionModifier(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 38: {
  /* from SPARQL.bgen, line 406
   * OrderClause: ORDER BY OrderConditionList
   */
  yyval = value_ptr[3];
  Py_INCREF(value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--OrderClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 39: {
  /* from SPARQL.bgen, line 419
   * OrderConditionList: OrderCondition
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--OrderConditionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 40: {
  /* from SPARQL.bgen, line 427
   * OrderConditionList: OrderConditionList OrderCondition
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--OrderConditionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 41: {
  /* from SPARQL.bgen, line 441
   * OrderCondition: ASC LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *t = PyObject_GetAttrString(SolutionModifier, "ASCENDING_ORDER");
  yyval = PyObject_CallMethod(SolutionModifier, "ParsedOrderConditionExpression", "OO",value_ptr[3],t);
  Py_XDECREF(t);
  if (self->verbose) {
    fprintf(stderr, "--OrderCondition(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 42: {
  /* from SPARQL.bgen, line 452
   * OrderCondition: DESC LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *t = PyObject_GetAttrString(SolutionModifier, "DESCENDING_ORDER");
  yyval = PyObject_CallMethod(SolutionModifier, "ParsedOrderConditionExpression", "OO",value_ptr[3],t);
  Py_XDECREF(t);
  if (self->verbose) {
    fprintf(stderr, "--OrderCondition(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 44: {
  /* from SPARQL.bgen, line 466
   * OrderCondition: LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *t = PyObject_GetAttrString(SolutionModifier, "UNSPECIFIED_ORDER");
  yyval = PyObject_CallMethod(SolutionModifier, "ParsedOrderConditionExpression", "OO",value_ptr[2],t);
  Py_XDECREF(t);
  if (self->verbose) {
    fprintf(stderr, "--OrderCondition(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 46: {
  /* from SPARQL.bgen, line 484
   * LimitClause: LIMIT NumericLiteral
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--LimitClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 47: {
  /* from SPARQL.bgen, line 497
   * OffsetClause: OFFSET NumericLiteral
   */
  yyval = value_ptr[2];
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--OffsetClause(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 48: {
  /* from SPARQL.bgen, line 511
   * GroupGraphPattern: LEFT_CURLY GraphPattern RIGHT_CURLY
   */
  yyval = PyObject_CallMethod(GraphPattern, "ParsedGraphPattern", "O",value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--GroupGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 49: {
  /* from SPARQL.bgen, line 542
   * GraphPattern: FilteredBasicGraphPattern
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],Py_None));
  if (self->verbose) {
    fprintf(stderr, "--GraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 50: {
  /* from SPARQL.bgen, line 549
   * GraphPattern: FilteredBasicGraphPattern GraphPatternNotTriples GraphPattern
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],value_ptr[2]),value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--GraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 51: {
  /* from SPARQL.bgen, line 557
   * GraphPattern: FilteredBasicGraphPattern GraphPatternNotTriples DOT GraphPattern
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],value_ptr[2]),value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--GraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 52: {
  /* from SPARQL.bgen, line 610
   * GraphPatternNotTriples: OPTIONAL GroupGraphPattern
   */
  yyval = PyObject_CallMethod(GraphPattern, "ParsedOptionalGraphPattern", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--GraphPatternNotTriples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 53: {
  /* from SPARQL.bgen, line 617
   * GraphPatternNotTriples: GroupGraphPattern AlternativeGroupGraphPatterns
   */
  /*PyObject *altPatterns = PyObject_CallMethod(GraphPattern, "GraphPattern", "OO", value_ptr[1],value_ptr[2]);*/
  yyval = PyObject_CallMethod(GraphPattern, "ParsedAlternativeGraphPattern", "OO", value_ptr[1],value_ptr[2]);
  /*Py_XDECREF(altPatterns);*/
  if (self->verbose) {
    fprintf(stderr, "--GraphPatternNotTriples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 54: {
  /* from SPARQL.bgen, line 657
   * AlternativeGroupGraphPatterns: UNION GroupGraphPattern
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--AlternativeGroupGraphPatterns(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 55: {
  /* from SPARQL.bgen, line 666
   * AlternativeGroupGraphPatterns: AlternativeGroupGraphPatterns UNION GroupGraphPattern
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--AlternativeGroupGraphPatterns(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 56: {
  /* from SPARQL.bgen, line 687
   * ConditionalOrExpression: ConditionalAndExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedConditionalAndExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalOrExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 57: {
  /* from SPARQL.bgen, line 693
   * ConditionalOrExpression: ConditionalAndExpression ConditionalAndExpressionList
   */
  yyval = PyObject_CallMethod(Expression, "ParsedConditionalAndExpressionList", "O", PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--ConditionalOrExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 58: {
  /* from SPARQL.bgen, line 705
   * ConditionalAndExpressionList: DOUBLE_PIPE ConditionalAndExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 59: {
  /* from SPARQL.bgen, line 714
   * ConditionalAndExpressionList: ConditionalAndExpressionList DOUBLE_PIPE ConditionalAndExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 60: {
  /* from SPARQL.bgen, line 729
   * ConditionalAndExpression: RelationalExpression ValueLogicalList
   */
  PyList_Append(value_ptr[2], value_ptr[1]);
  yyval = PyObject_CallMethod(Expression, "ParsedRelationalExpressionList", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 61: {
  /* from SPARQL.bgen, line 737
   * ConditionalAndExpression: RelationalExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedRelationalExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ConditionalAndExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 62: {
  /* from SPARQL.bgen, line 747
   * ValueLogicalList: DOUBLE_AMPERSAND RelationalExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--ValueLogicalList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 63: {
  /* from SPARQL.bgen, line 756
   * ValueLogicalList: ValueLogicalList DOUBLE_AMPERSAND RelationalExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--ValueLogicalList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 65: {
  /* from SPARQL.bgen, line 784
   * RelationalExpression: AdditiveExpression EQUALITY_OP AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "EqualityOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 66: {
  /* from SPARQL.bgen, line 792
   * RelationalExpression: AdditiveExpression NOT_EQUAL AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "NotEqualOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 67: {
  /* from SPARQL.bgen, line 800
   * RelationalExpression: AdditiveExpression LESS_THAN AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "LessThanOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 68: {
  /* from SPARQL.bgen, line 808
   * RelationalExpression: AdditiveExpression GREATER_THAN AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "GreaterThanOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 69: {
  /* from SPARQL.bgen, line 816
   * RelationalExpression: AdditiveExpression LESS_THAN_EQUAL AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "LessThanOrEqualOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 70: {
  /* from SPARQL.bgen, line 824
   * RelationalExpression: AdditiveExpression GREATER_THAN_EQUAL AdditiveExpression
   */
  yyval = PyObject_CallMethod(Operators, "GreaterThanOrEqualOperator", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RelationalExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 71: {
  /* from SPARQL.bgen, line 837
   * AdditiveExpression: MultiplicativeExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedAdditiveExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 72: {
  /* from SPARQL.bgen, line 843
   * AdditiveExpression: MultiplicativeExpression MultiplicativeExpressionList
   */
  yyval = PyObject_CallMethod(Expression, "ParsedAdditiveExpressionList", "O", PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--AdditiveExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 73: {
  /* from SPARQL.bgen, line 854
   * MultiplicativeExpressionList: PLUS MultiplicativeExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 74: {
  /* from SPARQL.bgen, line 863
   * MultiplicativeExpressionList: MINUS MultiplicativeExpression
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 75: {
  /* from SPARQL.bgen, line 872
   * MultiplicativeExpressionList: MultiplicativeExpressionList MINUS MultiplicativeExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 76: {
  /* from SPARQL.bgen, line 882
   * MultiplicativeExpressionList: MultiplicativeExpressionList PLUS MultiplicativeExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 77: {
  /* from SPARQL.bgen, line 897
   * MultiplicativeExpression: UnaryExpression
   */
  yyval = PyObject_CallMethod(Expression, "ParsedMultiplicativeExpressionList", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 78: {
  /* from SPARQL.bgen, line 903
   * MultiplicativeExpression: UnaryExpression UnaryExpressionList
   */
  yyval = PyObject_CallMethod(Expression, "ParsedMultiplicativeExpressionList", "O", PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--MultiplicativeExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 79: {
  /* from SPARQL.bgen, line 914
   * UnaryExpressionList: ASTERISK UnaryExpression
   */
                yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 80: {
  /* from SPARQL.bgen, line 923
   * UnaryExpressionList: FORWARDSLASH UnaryExpression
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[2]);
  Py_INCREF(value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 81: {
  /* from SPARQL.bgen, line 932
   * UnaryExpressionList: UnaryExpressionList ASTERISK UnaryExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 82: {
  /* from SPARQL.bgen, line 942
   * UnaryExpressionList: UnaryExpressionList FORWARDSLASH UnaryExpression
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpressionList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 83: {
  /* from SPARQL.bgen, line 957
   * UnaryExpression: BANG PrimaryExpression
   */
  yyval = PyObject_CallMethod(Operators, "LogicalNegation", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 84: {
  /* from SPARQL.bgen, line 964
   * UnaryExpression: PLUS PrimaryExpression
   */
  yyval = PyObject_CallMethod(Operators, "NumericPositive", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 85: {
  /* from SPARQL.bgen, line 971
   * UnaryExpression: MINUS PrimaryExpression
   */
  yyval = PyObject_CallMethod(Operators, "NumericNegative", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--UnaryExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 87: {
  /* from SPARQL.bgen, line 998
   * BuiltInCall: STR LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "STR");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 88: {
  /* from SPARQL.bgen, line 1012
   * BuiltInCall: LANG LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "LANG");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 89: {
  /* from SPARQL.bgen, line 1026
   * BuiltInCall: LANGMATCHES LEFT_PAREN ConditionalOrExpression COMMA ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyList_SET_ITEM(args, 0, value_ptr[5]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "LANGMATCHES");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  break;
}
case 90: {
  /* from SPARQL.bgen, line 1043
   * BuiltInCall: DATATYPE LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "DATATYPE");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 91: {
  /* from SPARQL.bgen, line 1057
   * BuiltInCall: BOUND LEFT_PAREN Var RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  Py_INCREF(value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "BOUND");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 92: {
  /* from SPARQL.bgen, line 1072
   * BuiltInCall: isIRI LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isIRI");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 93: {
  /* from SPARQL.bgen, line 1086
   * BuiltInCall: isURI LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isURI");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 94: {
  /* from SPARQL.bgen, line 1100
   * BuiltInCall: isBLANK LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isBLANK");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 95: {
  /* from SPARQL.bgen, line 1114
   * BuiltInCall: isLITERAL LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  PyObject *args = PyList_New(1);
  PyList_SET_ITEM(args, 0, value_ptr[3]);
  PyObject *funcName = PyObject_GetAttrString(FunctionLibrary, "isLITERAL");
  yyval = PyObject_CallMethod(FunctionLibrary, "BuiltinFunctionCall", "OO", funcName,args);
  Py_XDECREF(args);
  Py_XDECREF(funcName);
  if (self->verbose) {
    fprintf(stderr, "--BuiltInCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 97: {
  /* from SPARQL.bgen, line 1136
   * RegexExpression: REGEX LEFT_PAREN ConditionalOrExpression COMMA ConditionalOrExpression RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(FunctionLibrary, "ParsedREGEXInvocation", "OO", value_ptr[3],value_ptr[5]);
  if (self->verbose) {
    fprintf(stderr, "--RegexExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  break;
}
case 98: {
  /* from SPARQL.bgen, line 1147
   * RegexExpression: REGEX LEFT_PAREN ConditionalOrExpression COMMA ConditionalOrExpression COMMA ConditionalOrExpression RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(FunctionLibrary, "ParsedREGEXInvocation", "OOO", value_ptr[3],value_ptr[5],value_ptr[7]);
  if (self->verbose) {
    fprintf(stderr, "--RegexExpression(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[5], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[6], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[7], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[8], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  Py_DECREF(value_ptr[5]);
  Py_DECREF(value_ptr[6]);
  Py_DECREF(value_ptr[7]);
  Py_DECREF(value_ptr[8]);
  break;
}
case 99: {
  /* from SPARQL.bgen, line 1165
   * FunctionCall: IRIref LEFT_PAREN ArgumentList RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(FunctionLibrary, "FunctionCall", "OO", value_ptr[1], value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--FunctionCall(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 100: {
  /* from SPARQL.bgen, line 1184
   * ArgumentList: NIL
   */
  yyval = PyList_New(0);
  if (self->verbose) {
    fprintf(stderr, "--ArgumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 101: {
  /* from SPARQL.bgen, line 1190
   * ArgumentList: ConditionalOrExpression
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ArgumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 102: {
  /* from SPARQL.bgen, line 1199
   * ArgumentList: ConditionalOrExpression COMMA ArgumentList
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", value_ptr[1],value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--ArgumentList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 112: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 6
   * FilteredBasicGraphPattern:
   */
  yyval = PyList_New(0);
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    fprintf(stderr, ")\n");
  }
  break;
}
case 113: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 11
   * FilteredBasicGraphPattern: Triples
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 114: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 19
   * FilteredBasicGraphPattern: Triples Constraint DOT FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[4], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", value_ptr[1],value_ptr[2]));
  Py_INCREF(value_ptr[4]);
  yyval = value_ptr[4];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 115: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 30
   * FilteredBasicGraphPattern: Triples Constraint FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[3], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", value_ptr[1],value_ptr[2]));
  Py_INCREF(value_ptr[3]);
  yyval = value_ptr[3];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 116: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 40
   * FilteredBasicGraphPattern: Constraint DOT FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[3], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", Py_None,value_ptr[1]));
  Py_INCREF(value_ptr[3]);
  yyval = value_ptr[3];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 117: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 50
   * FilteredBasicGraphPattern: Constraint FilteredBasicGraphPattern
   */
  PyList_Append(value_ptr[2], PyObject_CallMethod(Triples, "ParsedConstrainedTriples", "OO", Py_None,value_ptr[1]));
  Py_INCREF(value_ptr[2]);
  yyval = value_ptr[2];
  if (self->verbose) {
    fprintf(stderr, "--FilteredBasicGraphPattern(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 118: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 66
   * Constraint: FILTER LEFT_PAREN ConditionalOrExpression RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(Filter, "ParsedExpressionFilter", "O", value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--Constraint(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 119: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 75
   * Constraint: FILTER BuiltInCall
   */
  yyval = PyObject_CallMethod(Filter, "ParsedFunctionFilter", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Constraint(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 120: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 82
   * Constraint: FILTER FunctionCall
   */
  yyval = PyObject_CallMethod(Filter, "ParsedFunctionFilter", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Constraint(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 121: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 99
   * Triples: Triples DOT TriplesSameSubject
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--Triples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 123: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 113
   * Triples: TriplesSameSubject
   */
  yyval = PyList_New(1);
  /* Steals a reference */
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Triples(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 124: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 139
   * TriplesSameSubject: Var PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 125: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 149
   * TriplesSameSubject: GraphTerm PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 126: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 159
   * TriplesSameSubject: LEFT_SQUARE PropertyListNotEmpty RIGHT_SQUARE PropertyList
   */
  yyval = PyObject_CallMethod(Resource, "TwiceReferencedBlankNode", "OO", value_ptr[2],value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 127: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 168
   * TriplesSameSubject: Collection PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", value_ptr[1],value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 128: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 175
   * TriplesSameSubject: Collection
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesSameSubject(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 131: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 201
   * PropertyListNotEmpty: Verb ObjectList
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, PyObject_CallMethod(Triples, "PropertyValue", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--PropertyListNotEmpty(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 132: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 209
   * PropertyListNotEmpty: Verb ObjectList SEMICOLON PropertyListNotEmpty
   */
  yyval = PyObject_CallMethod(Util, "ListPrepend", "OO", PyObject_CallMethod(Triples, "PropertyValue", "OO", value_ptr[1],value_ptr[2]),value_ptr[4]);
  if (self->verbose) {
    fprintf(stderr, "--PropertyListNotEmpty(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[4], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  Py_DECREF(value_ptr[4]);
  break;
}
case 133: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 218
   * PropertyListNotEmpty: Verb ObjectList SEMICOLON
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, PyObject_CallMethod(Triples, "PropertyValue", "OO", value_ptr[1],value_ptr[2]));
  if (self->verbose) {
    fprintf(stderr, "--PropertyListNotEmpty(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 134: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 234
   * ObjectList: GraphNode
   */
         yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--ObjectList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 135: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 245
   * ObjectList: ObjectList COMMA GraphNode
   */
  PyList_Append(value_ptr[1], value_ptr[3]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--ObjectList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 141: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 292
   * Verb: A
   */
  yyval = PyObject_GetAttrString(RDF, "type");
  if (self->verbose) {
    fprintf(stderr, "--Verb(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 143: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 313
   * TriplesNode: LEFT_SQUARE PropertyList RIGHT_SQUARE
   */
  yyval = PyObject_CallMethod(Resource, "Resource", "OO", Py_None,value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--TriplesNode(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 144: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 328
   * Collection: LEFT_PAREN GraphNodeList RIGHT_PAREN
   */
  yyval = PyObject_CallMethod(Resource, "ParsedCollection", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--Collection(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 145: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 340
   * GraphNodeList: GraphNode
   */
  yyval = PyList_New(1);
  PyList_SET_ITEM(yyval, 0, value_ptr[1]);
  Py_INCREF(value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--GraphNodeList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 146: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 348
   * GraphNodeList: GraphNodeList GraphNode
   */
  PyList_Append(value_ptr[1], value_ptr[2]);
  Py_INCREF(value_ptr[1]);
  yyval = value_ptr[1];
  if (self->verbose) {
    fprintf(stderr, "--GraphNodeList(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 147: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 362
   * Var: VARNAME
   */
  yyval = PyObject_CallMethod(rdflib, "Variable", "O", value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--Var(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 152: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 394
   * GraphTerm: MINUS NumericLiteral
   */
  PyObject *negNum = PyNumber_Negative(value_ptr[2]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", negNum);
  Py_XDECREF(negNum);
  if (self->verbose) {
    fprintf(stderr, "--GraphTerm(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 156: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 425
   * NumericLiteral: INTEGER
   */
         PyObject *num = PyNumber_Int(value_ptr[1]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", num);
         Py_XDECREF(num);
  if (self->verbose) {
    fprintf(stderr, "--NumericLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 157: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 437
   * NumericLiteral: DECIMAL
   */
         PyObject *num = PyNumber_Float(value_ptr[1]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", num);
         Py_XDECREF(num);
  if (self->verbose) {
    fprintf(stderr, "--NumericLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 158: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 449
   * NumericLiteral: DOUBLE
   */
         PyObject *num = PyNumber_Float(value_ptr[1]);
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", num);
         Py_XDECREF(num);
  if (self->verbose) {
    fprintf(stderr, "--NumericLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 160: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 471
   * RDFLiteral: String LANGTAG
   */
  PyObject *lang = PySequence_GetSlice(value_ptr[2], 1, PyString_GET_SIZE(value_ptr[2]));
  yyval = PyObject_CallMethod(rdflib, "Literal", "O", value_ptr[1],lang);
  Py_XDECREF(lang);
  if (self->verbose) {
    fprintf(stderr, "--RDFLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  break;
}
case 161: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 480
   * RDFLiteral: String DOUBLE_HAT IRIref
   */
  yyval = PyObject_CallMethod(rdflib, "Literal", "OOO", value_ptr[1],Py_None,value_ptr[3]);
  if (self->verbose) {
    fprintf(stderr, "--RDFLiteral(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 164: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 507
   * String: STRING_LITERAL_DELIMETER_1 STRING_LITERAL1 STRING_LITERAL_DELIMETER_1
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 165: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 515
   * String: STRING_LITERAL_DELIMETER_3 STRING_LITERAL2 STRING_LITERAL_DELIMETER_3
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 166: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 523
   * String: STRING_LITERAL_DELIMETER_2 STRING_LITERAL_LONG1 STRING_LITERAL_DELIMETER_2
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 167: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 531
   * String: STRING_LITERAL_DELIMETER_4 STRING_LITERAL_LONG2 STRING_LITERAL_DELIMETER_4
   */
  yyval = PyObject_CallMethod(Expression, "ParsedString", "O", value_ptr[2]);
  if (self->verbose) {
    fprintf(stderr, "--String(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[2], stderr, Py_PRINT_RAW);
    fprintf(stderr, ", ");
    PyObject_Print(value_ptr[3], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  Py_DECREF(value_ptr[2]);
  Py_DECREF(value_ptr[3]);
  break;
}
case 168: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 544
   * BlankNode: ANON
   */
  yyval = PyObject_CallMethod(rdflib, "BNode","");
  if (self->verbose) {
    fprintf(stderr, "--BlankNode(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
case 169: {
  /* from SPARQLTurtleSuperSet.bgen.frag, line 550
   * BlankNode: BLANK_NODE_LABEL
   */
  yyval = PyObject_CallMethod(rdflib, "BNode", "O",value_ptr[1]);
  if (self->verbose) {
    fprintf(stderr, "--BlankNode(");
    PyObject_Print(value_ptr[1], stderr, Py_PRINT_RAW);
    fprintf(stderr, ")\n");
  }
  Py_DECREF(value_ptr[1]);
  break;
}
      }
      if (!yyval) {
        lexer_free(lexer);
        return NULL;
      }
      *++value_ptr = yyval;

      if (self->verbose) print_state_stack(state_stack, state_ptr);

      /* Now "shift" the result of the reduction. */
      /* Determine what state that goes to, based on the state
         we popped back to and the rule number reduced by. */

      yyn = derives[yyn] - YYNTBASE;
      yystate = goto_idx[yyn] + *state_ptr;
      if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *state_ptr) {
        yystate = yytable[yystate];
      } else {
        yystate = default_goto[yyn];
      }
      continue;
    } else if (yyn == YYFINAL) {
      /* Hooray!  Process complete. */
      lexer_free(lexer);
      return value_ptr[-1];
    } else if (yyn <= 0) {
      /* Now it is either 0 or YYFLAG */
      return report_error(yystate, yylval, lexer);
    }

    /* Shift the lookahead token. */

    TRACE("Shifting token %d (%s), ", yychar, token_names[yychar1]);

    if (yychar != YYEOF) {
      yychar = YYEMPTY;
    }

    *++value_ptr = yylval;

    yystate = yyn;
    continue;
  }

  /* should never get here */
  Py_INCREF(Py_None);
  lexer_free(lexer);
  return Py_None;
}

/** lexer routines ****************************************************/

static lexerobject *lexer_new(PyObject *text)
{
  lexerobject *lexer;

  lexer = PyMem_New(lexerobject, 1);
  if (lexer == NULL) {
    PyErr_NoMemory();
    return NULL;
  }

  /* attempt to coerce given object to unicode using default rules */
  lexer->text = PyUnicode_FromObject(text);
  if (lexer->text == NULL) {
    PyMem_Free(lexer);
    return NULL;
  }
  lexer->position = PyUnicode_AS_UNICODE(lexer->text);
  lexer->end = lexer->position + PyUnicode_GET_SIZE(lexer->text);
  lexer->state = LEXER_START_STATE;

  /* create initial backtracking stack */
  lexer->positions = PyMem_New(Py_UNICODE *, LEXER_INITIAL_BACKTRACKS);
  if (lexer->positions == NULL) {
    PyErr_NoMemory();
    Py_DECREF(lexer->text);
    PyMem_Free(lexer);
    return NULL;
  }
  lexer->allocated = LEXER_INITIAL_BACKTRACKS;
  lexer->backtracks = 0;
  return lexer;
}

static void lexer_free(lexerobject *lexer)
{
  PyMem_Free(lexer->positions);
  Py_DECREF(lexer->text);
  PyMem_Free(lexer);
}

static int lexer_save_position(lexerobject *lexer) {
  Py_UNICODE **positions;
  size_t new_allocated;
  int allocated, newsize;

  /* Bypass realloc() when a previous overallocation is large enough
     to accommodate the newsize.
  */
  newsize = lexer->backtracks + 1;
  allocated = lexer->allocated;
  positions = lexer->positions;
  if (newsize >= allocated) {
    /* This over-allocates proportional to the list size, making room
     * for additional growth.  The over-allocation is mild, but is
     * enough to give linear-time amortized behavior over a long
     * sequence of appends() in the presence of a poorly-performing
     * system realloc().
     * The growth pattern is:  0, 4, 8, 16, 25, 35, 46, 58, 72, 88, ...
     */
    new_allocated = (newsize >> 3) + (newsize < 9 ? 3 : 6) + newsize;
    if (PyMem_Resize(positions, Py_UNICODE *, new_allocated) == NULL) {
      PyErr_NoMemory();
      return -1;
    }
    lexer->allocated = new_allocated;
    lexer->positions = positions;
  }
  lexer->positions[lexer->backtracks] = lexer->position;
  lexer->backtracks = newsize;
  return 0;
}

static Py_UNICODE *lexer_restore_position(lexerobject *lexer) {
  assert(lexer->backtracks > 0);
  lexer->position = lexer->positions[--lexer->backtracks];
  return lexer->position;
}

static int lexer_charset(parserobject *self, Py_UCS4 *set, Py_UCS4 ch,
			 int ok)
{
  unsigned char *charset;

  /* check if character is a member of the given set */
  /* Note, the tests are stored sorted to allow for quick exits */

  for (;;) {
    switch (*set++) {

    case LEXER_CHARSET_LITERAL:
      /* <LITERAL> <code> */
      REGEX_TRACE("CHARSET_LITERAL, %d == %d\n", ch, set[0]);
      if (ch < set[0])
        return !ok;
      else if ((Py_UCS4)ch == set[0])
        return ok;
      set++;
      break;

    case LEXER_CHARSET_RANGE:
      /* <RANGE> <lower> <upper> */
      REGEX_TRACE("CHARSET_RANGE, %d <= %d <= %d\n", set[0], ch, set[1]);
      if (ch < set[0])
        return !ok;
      else if (ch <= set[1])
        return ok;
      set += 2;
      break;

    case LEXER_CHARSET_SMALL:
      /* <SMALL> <charset index> */
      REGEX_TRACE("CHARSET_SMALL, index=%d\n", set[0]);
      charset = lexer_charsets[*set++];
      if (ch < 256 && (charset[ch >> 3] & (1 << (ch & 7))))
        return ok;
      break;

    case LEXER_CHARSET_BIG:
      /* <BIG> <blockmap index> */
      REGEX_TRACE("CHARSET_BIG, index=%d\n", set[0]);
      charset = lexer_charsets[lexer_blockmaps[*set++][ch >> 8]];
      if (ch < 65536 && charset[(ch & 255) >> 3] & (1 << (ch & 7)))
        return ok;
      break;

    case LEXER_CHARSET_FAILURE:
      /* nothing matched in charset */
      REGEX_TRACE("CHARSET_FAILURE\n");
      return !ok;

    default:
      REGEX_TRACE("**INTERNAL CHARSET ERROR**\n");
      return -1;
    }
  }
}

/* return values:
   1 -> sucessful match,
   0 -> no match,
   -1 -> error,
*/

#ifdef Py_UNICODE_WIDE
#define GET_CHAR_AND_ADVANCE() ch = *ptr++;
#else
#define GET_CHAR_AND_ADVANCE()                                          \
  if ((0xD800 <= ptr[0] && ptr[0] <= 0xDBFF) &&                         \
      (0xDC00 <= ptr[1] && ptr[1] <= 0xDFFF)) {                         \
    ch = (((ptr[0] & 0x03FF) << 10) | (ptr[1] & 0x03FF)) + 0x00010000;  \
    ptr += 2;                                                           \
  } else {                                                              \
    ch = *ptr++;                                                        \
  }
#endif  
    
static int lexer_match(parserobject *self, lexerobject *lexer, 
		       Py_UCS4 *pattern)
{
  Py_UNICODE *ptr = lexer->position;
  Py_UNICODE *end;
  Py_UCS4 ch;
  int i, count;

  REGEX_TRACE("LEXER_MATCH, position %d\n",
              lexer->position - PyUnicode_AS_UNICODE(lexer->text));

  while (1) {
    switch (*pattern++) {

    case LEXER_OP_FAILURE:
      /* immediate failure */
      REGEX_TRACE("OP_FAILURE\n");
      return 0;

    case LEXER_OP_SUCCESS:
      /* end of pattern */
      REGEX_TRACE("OP_SUCCESS\n");
      lexer->position = ptr;
      return 1;
        
    case LEXER_OP_BOL:
      /* beginning of line */
      /* <BOL> */
      REGEX_TRACE("OP_BOL\n");
      if (ptr == PyUnicode_AS_UNICODE(lexer->text) || ptr[-1] == '\n') 
        break;
      return 0;

    case LEXER_OP_EOL:
      /* end of line */
      /* <EOL> */
      REGEX_TRACE("OP_EOL\n");
      if (ptr >= lexer->end || ptr[0] == '\n') break;
      return 0;
            
    case LEXER_OP_EOF:
      /* end of file */
      /* <EOF> */
      REGEX_TRACE("OP_EOF\n");
      if (ptr >= lexer->end) break;
      return 0;

    case LEXER_OP_ANY:
      /* match anything (except a newline) */
      /* <ANY> */
      REGEX_TRACE("OP_ANY\n");
      if (ptr >= lexer->end || ptr[0] == '\n')
        return 0;
      ptr++;
      break;

    case LEXER_OP_LITERAL:
      /* match literal character */
      /* <LITERAL> <code> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_LITERAL, %d == %d\n", ch, pattern[0]);
      if (ch != pattern[0])
        return 0;
      pattern++;
      break;

    case LEXER_OP_NOT_LITERAL:
      /* match anything that is not literal character */
      /* <NOT_LITERAL> <code> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_NOT_LITERAL, %d != %d\n", ch, pattern[0]);
      if (ch == pattern[0])
        return 0;
      pattern++;
      break;

    case LEXER_OP_CHARSET:
      /* match set member */
      /* <CHARSET> <skip> <set> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_CHARSET, skip %d\n", pattern[0]);
      i = lexer_charset(self, pattern + 1, ch, 1);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;
            
    case LEXER_OP_NOT_CHARSET:
      /* match set non-member */
      /* <NOT_CHARSET> <skip> <set> */
      if (ptr >= lexer->end)
        return 0;
      GET_CHAR_AND_ADVANCE();
      REGEX_TRACE("OP_NOT_CHARSET, skip %d\n", pattern[0]);
      i = lexer_charset(self, pattern + 1, ch, 0);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;
            
    case LEXER_OP_ASSERT:
      /* lookahead assertion */
      /* <ASSERT> <skip> <pattern> */
      REGEX_TRACE("OP_ASSERT, skip %d\n", pattern[0]);
      lexer->position = ptr;
      i = lexer_match(self, lexer, pattern + 1);
      if (i <= 0)
        return i;

      pattern += pattern[0];
      break;

    case LEXER_OP_BRANCH:
      /* alternation */
      /* <BRANCH> <skip0> <code0> <skip1> <code1> ... <NULL> */

      end = NULL;
      count = 0;
      while (pattern[0]) {
        /* reset start position each time through */
	REGEX_TRACE("OP_BRANCH %d, skip %d\n", count++, pattern[0]);
        lexer->position = ptr;
        
        i = lexer_match(self, lexer, pattern + 1);
        if (i < 0)
          return i;
        else if (i && lexer->position > end) 
          /* successful match which is longer than the current best matched */
          end = lexer->position;
        
        /* advance to the next pattern */
        pattern += pattern[0];
      }

      /* advance pattern past NULL */
      pattern++;

      /* advance to the best matching position if there was a match */
      if (end) {
        lexer->position = ptr = end;
        break;
      }

      return 0;

    case LEXER_OP_REPEAT:
      /* repetition */
      /* <REPEAT> <skip> <1=min> item */
      {
        Py_UCS4 *item = pattern + 2;
        Py_UCS4 *next = pattern + pattern[0];
        int minimum = pattern[1];
        int backtracks;

        lexer->position = ptr;
        for (count = 0, i = 1; i == 1 && count < minimum; count++) {
          REGEX_TRACE("OP_REPEAT<stage 1>, min %d, now %d\n",
                      minimum, count);
          i = lexer_match(self, lexer, item);
        }
        
        /* either internal error or failed minimum matches */
        if (i <= 0) 
          return i;

        backtracks = lexer->backtracks;

        /* match as many items as possible */
        for (; i == 1; count++) {
          REGEX_TRACE("OP_REPEAT<stage 2>, now %d\n", count);
          if (lexer_save_position(lexer) < 0)
            return -1;
          i = lexer_match(self, lexer, item);
        }
          
        if (i < 0) {
          /* internal error */
          lexer->backtracks = backtracks;
          return i;
        }
          
        /* backtracking assert of tail match until success */
        do {
          REGEX_TRACE("OP_REPEAT<stage 3>, now %d\n", count);
          /* update position to previous successful match */
          ptr = lexer_restore_position(lexer);
          if (ptr == NULL)
            return -1;
          i = lexer_match(self, lexer, next);
        } while (i == 0 && --count > minimum);

        /* discard remaining backtrack positions */
        lexer->backtracks = backtracks;

        if (i <= 0) {
          return i;
        }
        pattern = next;
      }
      break;

    case LEXER_OP_REPEAT_RANGE:
      /* repetition */
      /* <REPEAT_RANGE> <skip> <1=min> <2=max> item */
      {
        Py_UCS4 *item = pattern + 3;
        Py_UCS4 *next = pattern + pattern[0];
        int minimum = pattern[1];
        int maximum = pattern[2];
        int backtracks;

        lexer->position = ptr;
        for (count = 0, i = 1; i == 1 && count < minimum; count++) {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 1>, min %d, now %d\n",
                      minimum, count);
          i = lexer_match(self, lexer, item);
        }
        
        /* either internal error or failed minimum matches */
        if (i <= 0) 
          return i;

        backtracks = lexer->backtracks;

        /* consume up to 'maximum' matches */
        for (; i == 1 && count < maximum; count++) {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 2>, max %d, now %d\n",
                      maximum, count);
          if (lexer_save_position(lexer) < 0)
            return -1;
          i = lexer_match(self, lexer, item);
        }

        if (i < 0) {
          /* internal error */
          lexer->backtracks = backtracks;
          return i;
        }

        /* maximum matches reached, update saved position */
        if (i == 1)
          ptr = lexer->position;

        /* backtracking assert of tail match until success */
        do {
          REGEX_TRACE("OP_REPEAT_RANGE<stage 3>, now %d\n", count);
          if (i == 0) {
            /* update position to last successful match */
            ptr = lexer_restore_position(lexer);
            if (ptr == NULL)
              return -1;
          }
          i = lexer_match(self, lexer, next);
        } while (i == 0 && --count > minimum);

        /* discard remaining backtrack positions */
        lexer->backtracks = backtracks;

        if (i <= 0)
          return i;

        pattern = next;
      }
      break;

    default:
      REGEX_TRACE("**INTERNAL MATCH ERROR**\n");
      return -1;
    }
  }
}

static int parser_yylex(parserobject *self, lexerobject *lexer,
			PyObject **yylval)
{
  int yychar = YYEMPTY;
  int yylen;
  Py_UNICODE *yytext = lexer->position;
  
  while (yytext < lexer->end && yychar == YYEMPTY) {
    Py_UNICODE *best_end = NULL;
    int yyaccept = 0;
    int i;
    Py_UCS4 **patterns = (Py_UCS4 **)lexer_patterns[lexer->state];
    const int *actions = lexer_actions[lexer->state];

    REGEX_TRACE("Using patterns from lexer state %d\n", lexer->state);
    for (i = 0; patterns[i]; i++) {
      int matched;
      /* reset position each time through */
      lexer->position = yytext;

      REGEX_TRACE("--- pattern %d...\n", i);
      matched = lexer_match(self, lexer, patterns[i]);
      
      if (matched > 0 && lexer->position > best_end) {
        /* successful match which is longer than the current best matched */
        best_end = lexer->position;
        yyaccept = i;
      } else if (matched < 0) {
        /* internal error */
	REGEX_TRACE("--- pattern %d internal error\n", i);
        PyErr_SetString(PyExc_RuntimeError,
                        "internal error in regular expression engine");
        return -1;
      }
      REGEX_TRACE("--- pattern %d %s\n", i, matched ? "success" : "failed");
    }
      
    if (best_end == NULL) {
      /* no matches */
      lexer->position = yytext;
      lexer_error(lexer);
      return -1;
    }

    lexer->position = best_end;
    yylen = best_end - yytext;

    /* get the action block for this match */
    switch (actions[yyaccept]) {
case 0: {
  /* from SPARQLLexerPatterns.bgen.frag, line 69 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[69], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = Q_IRI_CONTENT;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 1: {
  /* from SPARQLLexerPatterns.bgen.frag, line 72 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[72], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = GREATER_THAN;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 2: {
  /* from SPARQLLexerPatterns.bgen.frag, line 76 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[76], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  break;
}
case 3: {
  /* from SPARQLLexerPatterns.bgen.frag, line 13 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[13], ");
  lexer->state = LEXER_STRING_MODE_SHORT_1;
  TRACE("switching to start condition STRING_MODE_SHORT_1, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL_DELIMETER_1;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 4: {
  /* from SPARQLLexerPatterns.bgen.frag, line 17 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[17], ");
  lexer->state = LEXER_STRING_MODE_LONG_1;
  TRACE("switching to start condition STRING_MODE_LONG_1, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL_DELIMETER_2;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 5: {
  /* from SPARQLLexerPatterns.bgen.frag, line 21 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[21], ");
  lexer->state = LEXER_STRING_MODE_SHORT_2;
  TRACE("switching to start condition STRING_MODE_SHORT_2, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL_DELIMETER_3;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 6: {
  /* from SPARQLLexerPatterns.bgen.frag, line 25 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[25], ");
  lexer->state = LEXER_STRING_MODE_LONG_2;
  TRACE("switching to start condition STRING_MODE_LONG_2, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL_DELIMETER_4;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 7: {
  /* from SPARQLLexerPatterns.bgen.frag, line 29 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[29], ");
  lexer->state = LEXER_IRI_MODE;
  TRACE("switching to start condition IRI_MODE, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LESS_THAN;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 8: {
  /* from SPARQLLexerPatterns.bgen.frag, line 34 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[34], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LANGTAG;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 9: {
  /* from SPARQLLexerPatterns.bgen.frag, line 37 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[37], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = NIL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 10: {
  /* from SPARQLLexerPatterns.bgen.frag, line 40 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[40], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = ANON;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 11: {
  /* from SPARQLLexerPatterns.bgen.frag, line 43 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[43], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = QNAME;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 12: {
  /* from SPARQLLexerPatterns.bgen.frag, line 46 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[46], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = QNAME_NS;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 13: {
  /* from SPARQLLexerPatterns.bgen.frag, line 49 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[49], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = BLANK_NODE_LABEL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 14: {
  /* from SPARQLLexerPatterns.bgen.frag, line 52 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[52], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = VARNAME;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 15: {
  /* from SPARQLLexerPatterns.bgen.frag, line 55 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[55], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LANGTAG;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 16: {
  /* from SPARQLLexerPatterns.bgen.frag, line 58 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[58], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = INTEGER;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 17: {
  /* from SPARQLLexerPatterns.bgen.frag, line 61 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[61], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DECIMAL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 18: {
  /* from SPARQLLexerPatterns.bgen.frag, line 64 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[64], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DOUBLE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 19: {
  /* from SPARQLLexerPatterns.bgen.frag, line 120 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[120], ");
  /* skip over the matched text */
  yytext = lexer->position;
  break;
}
case 20: {
  /* from SPARQLLexerPatterns.bgen.frag, line 122 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[122], ");
  /* skip over the matched text */
  yytext = lexer->position;
  break;
}
case 21: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 3 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[3], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = UNION;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 22: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 6 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[6], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = ASTERISK;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 23: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 9 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[9], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = BASE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 24: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 12 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[12], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = PREFIX;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 25: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 15 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[15], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = SELECT;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 26: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 18 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[18], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DISTINCT;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 27: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 21 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[21], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = FROM;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 28: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 24 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[24], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = NAMED;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 29: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 27 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[27], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = OPTIONAL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 30: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 30 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[30], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = FILTER;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 31: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 33 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[33], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = GRAPH;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 32: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 36 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[36], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = WHERE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 33: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 39 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[39], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = ORDER;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 34: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 42 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[42], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = BY;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 35: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 45 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[45], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = ASC;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 36: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 48 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[48], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DESC;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 37: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 51 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[51], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LIMIT;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 38: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 54 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[54], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = OFFSET;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 39: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 57 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[57], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STR;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 40: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 60 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[60], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LANG;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 41: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 63 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[63], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LANGMATCHES;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 42: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 66 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[66], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DATATYPE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 43: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 69 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[69], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = isIRI;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 44: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 72 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[72], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = isURI;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 45: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 75 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[75], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = isBLANK;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 46: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 78 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[78], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = isLITERAL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 47: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 81 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[81], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = BOUND;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 48: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 84 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[84], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = REGEX;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 49: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 87 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[87], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = TRUE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 50: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 90 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[90], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = FALSE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 51: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 93 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[93], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = A;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 52: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 96 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[96], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = MINUS;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 53: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 99 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[99], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = PLUS;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 54: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 102 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[102], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DOUBLE_AMPERSAND;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 55: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 105 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[105], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DOUBLE_PIPE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 56: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 108 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[108], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = BANG;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 57: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 111 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[111], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DOUBLE_HAT;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 58: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 114 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[114], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = COMMA;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 59: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 117 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[117], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = QUESTION_MARK;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 60: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 120 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[120], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DOLLAR;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 61: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 123 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[123], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = FORWARDSLASH;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 62: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 126 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[126], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LEFT_PAREN;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 63: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 129 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[129], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = RIGHT_PAREN;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 64: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 132 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[132], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LEFT_SQUARE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 65: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 135 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[135], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = RIGHT_SQUARE;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 66: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 138 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[138], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = EQUALITY_OP;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 67: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 141 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[141], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = NOT_EQUAL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 68: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 144 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[144], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LESS_THAN;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 69: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 147 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[147], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = GREATER_THAN;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 70: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 150 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[150], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LESS_THAN_EQUAL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 71: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 153 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[153], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = GREATER_THAN_EQUAL;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 72: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 156 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[156], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = SEMICOLON;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 73: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 159 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[159], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = LEFT_CURLY;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 74: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 162 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[162], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = RIGHT_CURLY;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 75: {
  /* from SPARQLLiteralLexerPatterns.bgen.frag, line 165 */
  TRACE("using rule from SPARQLLiteralLexerPatterns.bgen.frag[165], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = DOT;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 76: {
  /* from SPARQLLexerPatterns.bgen.frag, line 91 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[91], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL2;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 77: {
  /* from SPARQLLexerPatterns.bgen.frag, line 94 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[94], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL_DELIMETER_3;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 78: {
  /* from SPARQLLexerPatterns.bgen.frag, line 82 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[82], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL1;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 79: {
  /* from SPARQLLexerPatterns.bgen.frag, line 85 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[85], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL_DELIMETER_1;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 80: {
  /* from SPARQLLexerPatterns.bgen.frag, line 110 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[110], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL_LONG2;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 81: {
  /* from SPARQLLexerPatterns.bgen.frag, line 113 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[113], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL_DELIMETER_4;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 82: {
  /* from SPARQLLexerPatterns.bgen.frag, line 101 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[101], ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL_LONG1;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
case 83: {
  /* from SPARQLLexerPatterns.bgen.frag, line 104 */
  TRACE("using rule from SPARQLLexerPatterns.bgen.frag[104], ");
  lexer->state = LEXER_INITIAL;
  TRACE("switching to start condition INITIAL, ");
  /* create the Python object for the matched text */
  *yylval = PyUnicode_FromUnicode(yytext, yylen);
  if (*yylval == NULL) {
    PyErr_NoMemory();
    return -1;
  }

  yychar = STRING_LITERAL_DELIMETER_2;

  if (self->verbose) {
    char *repr = unicode_escape(yytext, yylen);
    TRACE("accepting '%s' (%d)\n", repr, yychar);
    PyMem_Del(repr);
  }

  /* update the saved position */
  yytext = lexer->position;
  break;
}
    }
  }

  if (yychar == YYEMPTY) {
    /* Reached end of input */
    yychar = YYEOF;
  }

  return yychar;
}

/** Type Object *******************************************************/

static int parser_traverse(parserobject *self, visitproc visit, void *arg)
{
  int rv;

  if (self->dict) {
    rv = visit(self->dict, arg);
    if (rv != 0) return rv;
  }
  return 0;
}

static int parser_clear(parserobject *self)
{
  PyObject *tmp;

  if (self->dict) {
    tmp = self->dict;
    self->dict = NULL;
    Py_DECREF(tmp);
  }
  return 0;
}

static void parser_dealloc(parserobject *self)
{
  parser_clear(self);
  self->ob_type->tp_free((PyObject *) self);
}

static int parser_init(parserobject *self, PyObject *args, PyObject *kwds)
{
  PyObject *debug=NULL;
  static char *kwlist[] = { "debug", NULL };

  if (!PyArg_ParseTupleAndKeywords(args, kwds, "|O:" PARSER_NAME, kwlist,
                                   &debug))
    return -1;

  if (debug) {
    self->verbose = PyObject_IsTrue(debug);
  }

  return 0;
}

static PyObject *parser_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
  parserobject *self;

  self = (parserobject *) type->tp_alloc(type, 0);
  if (self != NULL) {
    self->dict = PyDict_New();
    if (self->dict == NULL) {
      Py_DECREF(self);
      return NULL;
    }
    self->verbose = 0;
  }
  return (PyObject *) self;
}

static PyMethodDef parser_methods[] = {
  { "parse", (PyCFunction) parser_parse, METH_O, parse_doc },
  { NULL, NULL }
};

static PyMemberDef parser_members[] = {
  { "debug", T_INT, offsetof(parserobject, verbose) },
  { NULL }
};

static char parser_doc[] = PARSER_NAME "\
([debug]) -> parser\n\
Create a new parser object.\n\
\n\
The optional debug argument, when true, enables the builtin trace facility.\n\
The trace facility uses stderr to display each step taken by the parser.";

static PyTypeObject Parser_Type = {
  /* PyObject_HEAD     */ PyObject_HEAD_INIT(NULL)
  /* ob_size           */ 0,
  /* tp_name           */ PROJECT_NAME "." PARSER_NAME,
  /* tp_basicsize      */ sizeof(parserobject),
  /* tp_itemsize       */ 0,
  /* tp_dealloc        */ (destructor) parser_dealloc,
  /* tp_print          */ (printfunc) 0,
  /* tp_getattr        */ (getattrfunc) 0,
  /* tp_setattr        */ (setattrfunc) 0,
  /* tp_compare        */ (cmpfunc) 0,
  /* tp_repr           */ (reprfunc) 0,
  /* tp_as_number      */ (PyNumberMethods *) 0,
  /* tp_as_sequence    */ (PySequenceMethods *) 0,
  /* tp_as_mapping     */ (PyMappingMethods *) 0,
  /* tp_hash           */ (hashfunc) 0,
  /* tp_call           */ (ternaryfunc) 0,
  /* tp_str            */ (reprfunc) 0,
  /* tp_getattro       */ (getattrofunc) 0,
  /* tp_setattro       */ (setattrofunc) 0,
  /* tp_as_buffer      */ (PyBufferProcs *) 0,
  /* tp_flags          */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
  /* tp_doc            */ (char *) parser_doc,
  /* tp_traverse       */ (traverseproc) parser_traverse,
  /* tp_clear          */ (inquiry) parser_clear,
  /* tp_richcompare    */ (richcmpfunc) 0,
  /* tp_weaklistoffset */ 0,
  /* tp_iter           */ (getiterfunc) 0,
  /* tp_iternext       */ (iternextfunc) 0,
  /* tp_methods        */ (PyMethodDef *) parser_methods,
  /* tp_members        */ (PyMemberDef *) parser_members,
  /* tp_getset         */ (PyGetSetDef *) 0,
  /* tp_base           */ (PyTypeObject *) 0,
  /* tp_dict           */ (PyObject *) 0,
  /* tp_descr_get      */ (descrgetfunc) 0,
  /* tp_descr_set      */ (descrsetfunc) 0,
  /* tp_dictoffset     */ offsetof(parserobject, dict),
  /* tp_init           */ (initproc) parser_init,
  /* tp_alloc          */ (allocfunc) 0,
  /* tp_new            */ (newfunc) parser_new,
  /* tp_free           */ 0,
};

/* Helper functions */

/* caller is responsible for releasing the memory */
static char *unicode_escape(Py_UNICODE *s, int len)
{
  static const char *hexdigit = "0123456789ABCDEF";
  char *repr, *p;
  int i, size;

  /* Do one pass to get the repr'ed size */
  size = 1;  /* zero terminator */
  for (i = 0; i < len; i++) {
#ifdef Py_UNICODE_WIDE
    if (s[i] >= 65536) size += 10;  /* \UHHHHHHHH */
    else
#endif
    if (s[i] >= 256) size += 6;  /* \uHHHH */
    else if (s[i] == 9 || s[i] == 10 || s[i] == 13) size += 2;  /* \t \n \r */
    else if (s[i] < 32 || s[i] >= 128) size += 4;  /* \xHH */
    else size++; /* printable US-ASCII */
  }
  
  repr = p = PyMem_New(char, size + 1);
  if (repr == NULL) return NULL;

  while (len-- > 0) {
    Py_UNICODE ch = *s++;
#ifdef Py_UNICODE_WIDE
    /* Map 32-bit characters to '\Uxxxxxxxx' */
    if (ch >= 65536) {
      *p++ = '\\';
      *p++ = 'U';
      *p++ = hexdigit[(ch >> 28) & 0xf];
      *p++ = hexdigit[(ch >> 24) & 0xf];
      *p++ = hexdigit[(ch >> 20) & 0xf];
      *p++ = hexdigit[(ch >> 16) & 0xf];
      *p++ = hexdigit[(ch >> 12) & 0xf];
      *p++ = hexdigit[(ch >> 8) & 0xf];
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Map 16-bit characters to '\uxxxx' */
    else 
#endif
    if (ch >= 256) {
      *p++ = '\\';
      *p++ = 'u';
      *p++ = hexdigit[(ch >> 12) & 0xf];
      *p++ = hexdigit[(ch >> 8) & 0xf];
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Map special whitespace to '\t', \n', '\r' */
    else if (ch == 9) {
      *p++ = '\\';
      *p++ = 't';
    }
    else if (ch == 10) {
      *p++ = '\\';
      *p++ = 'n';
    }
    else if (ch == 13) {
      *p++ = '\\';
      *p++ = 'r';
    }
    /* Map non-printable US ASCII to '\xhh' */
    else if (ch < 32 || ch >= 128) {
      *p++ = '\\';
      *p++ = 'x';
      *p++ = hexdigit[(ch >> 4) & 0xf];
      *p++ = hexdigit[ch & 15];
    }
    /* Copy everything else as-is */
    else
      *p++ = (char) ch;
  }

  *p = '\0';

  return repr;
}

static void calculate_position(lexerobject *lexer, int *line, int *column) {
  /* Determine line and column numbers */
  Py_UNICODE *p;

  *line = 1;
  *column = 1;

  for (p = PyUnicode_AS_UNICODE(lexer->text); p < lexer->end; p++) {
    if ((char)*p == '\n') {
      *line += 1;
      *column = 1;
    } else {
      *column += 1;
    }
  }
}

static const char error_format_str[] = "parse error at line %d, column %d: matched '%s'";
static const char error_format_eof_str[] = "parse error at line %d, column %d: reached end-of-input";

static PyObject *report_error(int state, PyObject* lval, lexerobject *lexer) {
  int line, column;
  int ruleno = action_idx[state];
  char *matched = NULL;

  if (lval) {
    matched = unicode_escape(PyUnicode_AS_UNICODE(lval), 
                             PyUnicode_GET_SIZE(lval));
    if (matched == NULL) return NULL;
  }

  calculate_position(lexer, &line, &column);
  Py_DECREF(lexer->text);

  if (ruleno > YYFLAG && ruleno < YYLAST) {
    /* There are expected tokens */
    int x, count;
    int size = 60;  /* Initial format string */
    char *msg;

    /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
    for (x = (ruleno < 0 ? -ruleno : 0);
         x < (sizeof(token_names) / sizeof(char *)); x++) {
      if (yycheck[x + ruleno] == x) {
        size += strlen(token_names[x]) + 15;
      }
    }

    msg = PyMem_New(char, size);
    if (msg == NULL) {
      PyMem_Del(matched);
      return NULL;
    }

    if (lval) {
      strcpy(msg, error_format_str);
    } else {
      strcpy(msg, error_format_eof_str);
    }

    count = 0;
    for (x = (ruleno < 0 ? -ruleno : 0);
         x < (sizeof(token_names) / sizeof(char *)); x++) {
      if (yycheck[x + ruleno] == x) {
        strcat(msg, count == 0 ? ", expecting '" : " or '");
        strcat(msg, token_names[x]);
        strcat(msg, "'");
        count++;
      }
    }
    if (matched) {
      PyErr_Format(PyExc_SyntaxError, msg, line, column, matched);
    } else {
      PyErr_Format(PyExc_SyntaxError, msg, line, column);
    }
    PyMem_Del(msg);
  } else {
    if (matched) {
      PyErr_Format(PyExc_SyntaxError, error_format_str, line, column, matched);
    } else {
      PyErr_Format(PyExc_SyntaxError, error_format_eof_str, line, column);
    }
  }

  if (matched) {
    PyMem_Del(matched);
  }

  return NULL;
}

static const char lexer_error_str[] = "lexical error at line %d, column %d: no action found for '%s'";

static void lexer_error(lexerobject *lexer)
{
  int line, column;
  char *repr = unicode_escape(lexer->position, (lexer->end - lexer->position));
  if (repr == NULL) return;

  calculate_position(lexer, &line, &column);

  PyErr_Format(PyExc_SyntaxError, lexer_error_str, line, column, repr);

  PyMem_Del(repr);
  return;
}

static void print_reduce(int ruleno) {
  int count;
  const int *token;

  PySys_WriteStderr("Reducing via rule %d (%s), ", ruleno, rule_info[ruleno]);
  /* print the symbols being reduced and their result. */

  count = ruleno;
  token = rhs_tokens;
  while (--count) while (*++token);

  while (*++token) {
    PySys_WriteStderr("%s ", token_names[*token]);
  }
  PySys_WriteStderr("-> %s\n", token_names[derives[ruleno]]);
}

static void print_state_stack(int *stack, int *end) {
  int *curr = stack;

  PySys_WriteStderr("state stack now");
  while (curr <= end) {
    PySys_WriteStderr(" %d", *curr++);
  }
  PySys_WriteStderr("\n");
}

/** Interactive parser ************************************************/

#define CONSOLE_NAME PARSER_NAME "Console"

typedef struct {
  PyObject_HEAD
  parserobject *parser;
  PyObject *dict;
} consoleobject;

static PyObject *console_new(PyTypeObject *type, PyObject *args,
			     PyObject *kwds)
{
  consoleobject *self;

  self = (consoleobject *) type->tp_alloc(type, 0);
  if (self != NULL) {
    PyObject *args = Py_BuildValue("(i)", 1);
    if (args == NULL) {
      Py_DECREF(self);
      return NULL;
    }
    self->parser = (parserobject *) parser_new(&Parser_Type, args, NULL);
    Py_DECREF(args);
    if (self->parser == NULL) {
      Py_DECREF(self);
      return NULL;
    }
  }
  return (PyObject *) self;
}

static int console_init(consoleobject *self, PyObject *args, PyObject *kwds)
{
  PyObject *bases, *base, *result;
  int size, i;

  if (!PyArg_ParseTuple(args, ":" CONSOLE_NAME)) return -1;

  bases = self->ob_type->tp_bases;
  size = PyTuple_GET_SIZE(bases);
  for (i = 0; i < size; i++) {
    base = PyTuple_GET_ITEM(bases, i);
    result = PyObject_CallMethod(base, "__init__", "O", (PyObject *) self);
    if (result == NULL) return -1;
    Py_DECREF(result);
  }
  return 0;
}

static void console_dealloc(consoleobject *self)
{
  Py_XDECREF(self->parser);
  self->ob_type->tp_free((PyObject *) self);
}

static PyObject *console_cmdloop(consoleobject *self, PyObject *args)
{
  PyObject *result=NULL, *builtins=NULL, *readline=NULL, *old_completer=NULL;
  int stop;

  builtins = PyImport_ImportModule("__builtin__");
  if (builtins == NULL) goto exit;

  readline = PyImport_ImportModule("readline");
  if (readline == NULL) {
    if (!PyErr_ExceptionMatches(PyExc_ImportError)) goto exit;
    PyErr_Clear();
  } else {
#if PY_VERSION_HEX > 0x02030000
    /* old_completer = readline.get_completer() */
    old_completer = PyObject_CallMethod(readline, "get_completer", NULL);
    if (old_completer == NULL) goto exit;
#endif
    /* readline.set_completer(self.complete) */
    result = PyObject_GetAttrString((PyObject *) self, "complete");
    if (result == NULL) goto exit;
    result = PyObject_CallMethod(readline, "set_completer", "N", result);
    if (result == NULL) goto exit;
    Py_DECREF(result);
    /* readline.parse_and_bind("tab: complete") */
    result = PyObject_CallMethod(readline, "parse_and_bind", "s",
				 "tab: complete");
    if (result == NULL) goto exit;
    Py_DECREF(result);
  }

  stop = 0;
  do {
    result = PyObject_GetAttrString((PyObject *) self, "prompt");
    if (result == NULL) goto finally;
    result = PyObject_CallMethod(builtins, "raw_input", "N", result);
    if (result == NULL) {
      if (PyErr_ExceptionMatches(PyExc_EOFError) ||
	  PyErr_ExceptionMatches(PyExc_KeyboardInterrupt)) {
	PyErr_Clear();
	PySys_WriteStdout("\n");
	Py_INCREF(Py_None);
	result = Py_None;
      }
      goto finally;
    }
    result = PyObject_CallMethod((PyObject *) self, "onecmd", "N", result);
    if (result == NULL) goto finally;
    stop = PyObject_IsTrue(result);
    Py_DECREF(result);
  } while (!stop);

  Py_INCREF(Py_None);
  result = Py_None;

 finally:
#if PY_VERSION_HEX > 0x02030000
  if (readline != NULL && old_completer != NULL) {
    PyObject *rv;
    rv = PyObject_CallMethod(readline, "set_completer", "O", old_completer);
    if (rv == NULL) {
      Py_XDECREF(result);
      result = rv;
    } else {
      Py_DECREF(rv);
    }
  }
#endif
 exit:
  Py_XDECREF(old_completer);
  Py_XDECREF(readline);
  Py_XDECREF(builtins);
  return result;
}

static PyObject *console_emptyline(consoleobject *self, PyObject *noarg)
{
  Py_INCREF(Py_None);
  return Py_None;
}

static char console_exit_doc[] = "terminate the console";

static PyObject *console_exit(consoleobject *self, PyObject *arg)
{
  Py_INCREF(Py_True);
  return Py_True;
}

static char console_debug_doc[] = "sets or displays the debug level";

static PyObject *console_debug(consoleobject *self, PyObject *arg)
{
  PyObject *verbose;

  if (PyObject_IsTrue(arg)) {
    if ((verbose = PyNumber_Int(arg)) == NULL) {
      if (PyErr_ExceptionMatches(PyExc_ValueError)) {
	PyErr_Clear();
	PySys_WriteStdout("usage: debug <level>\n");
	Py_INCREF(Py_None);
	return Py_None;
      }
      return NULL;
    }
    self->parser->verbose = PyInt_AsLong(verbose);
    Py_DECREF(verbose);
  }
  PySys_WriteStdout("debug level is %d\n", self->parser->verbose);
  Py_INCREF(Py_None);
  return Py_None;
}

static char console_parse_doc[] = "parses an expression";

static PyObject *console_parse(consoleobject *self, PyObject *arg)
{
  PyObject *result, *value;

  result = parser_parse(self->parser, arg);
  if (result == NULL) {
    PyObject *exc, *tb;
    if (!PyErr_ExceptionMatches(PyExc_SyntaxError)) return NULL;
    PyErr_Fetch(&exc, &value, &tb);
    if (value && value != Py_None) {
      result = PyObject_Str(value);
    }
    Py_XDECREF(exc);
    Py_XDECREF(value);
    Py_XDECREF(tb);
    if (result == NULL) return NULL;
  }

  value = PyObject_Str(result);
  Py_DECREF(result);
  if (value == NULL) return NULL;

  PySys_WriteStdout("%s\n", PyString_AsString(value));
  Py_DECREF(value);

  Py_INCREF(Py_None);
  return Py_None;
}

static PyMethodDef console_methods[] = {
  { "cmdloop", (PyCFunction) console_cmdloop, METH_O },
  { "emptyline", (PyCFunction) console_emptyline, METH_NOARGS },
  { "do_exit", (PyCFunction) console_exit, METH_O, console_exit_doc },
  { "do_quit", (PyCFunction) console_exit, METH_O, console_exit_doc },
  { "do_debug", (PyCFunction) console_debug, METH_O, console_debug_doc },
  { "do_parse", (PyCFunction) console_parse, METH_O, console_parse_doc },
  { NULL }
};

static PyTypeObject Console_Type = {
  /* PyObject_HEAD     */ PyObject_HEAD_INIT(NULL)
  /* ob_size           */ 0,
  /* tp_name           */ "Console",
  /* tp_basicsize      */ sizeof(consoleobject),
  /* tp_itemsize       */ 0,
  /* tp_dealloc        */ (destructor) console_dealloc,
  /* tp_print          */ (printfunc) 0,
  /* tp_getattr        */ (getattrfunc) 0,
  /* tp_setattr        */ (setattrfunc) 0,
  /* tp_compare        */ (cmpfunc) 0,
  /* tp_repr           */ (reprfunc) 0,
  /* tp_as_number      */ (PyNumberMethods *) 0,
  /* tp_as_sequence    */ (PySequenceMethods *) 0,
  /* tp_as_mapping     */ (PyMappingMethods *) 0,
  /* tp_hash           */ (hashfunc) 0,
  /* tp_call           */ (ternaryfunc) 0,
  /* tp_str            */ (reprfunc) 0,
  /* tp_getattro       */ (getattrofunc) 0,
  /* tp_setattro       */ (setattrofunc) 0,
  /* tp_as_buffer      */ (PyBufferProcs *) 0,
  /* tp_flags          */ Py_TPFLAGS_DEFAULT,
  /* tp_doc            */ (char *) 0,
  /* tp_traverse       */ (traverseproc) 0,
  /* tp_clear          */ (inquiry) 0,
  /* tp_richcompare    */ (richcmpfunc) 0,
  /* tp_weaklistoffset */ 0,
  /* tp_iter           */ (getiterfunc) 0,
  /* tp_iternext       */ (iternextfunc) 0,
  /* tp_methods        */ (PyMethodDef *) console_methods,
  /* tp_members        */ (PyMemberDef *) 0,
  /* tp_getset         */ (PyGetSetDef *) 0,
  /* tp_base           */ (PyTypeObject *) 0,
  /* tp_dict           */ (PyObject *) 0,
  /* tp_descr_get      */ (descrgetfunc) 0,
  /* tp_descr_set      */ (descrsetfunc) 0,
  /* tp_dictoffset     */ offsetof(consoleobject, dict),
  /* tp_init           */ (initproc) console_init,
  /* tp_alloc          */ (allocfunc) 0,
  /* tp_new            */ (newfunc) console_new,
  /* tp_free           */ 0,
};

static char console_doc[] = CONSOLE_NAME "\
()\n\
Starts an interactive parser console.";

static PyObject *module_console(PyObject *module, PyObject *args)
{
  PyObject *console, *result;

  args = PyTuple_New(0);
  if (args == NULL) return NULL;

  console = PyObject_Call((PyObject *) &Console_Type, args, NULL);
  if (console == NULL) {
    Py_DECREF(args);
    return NULL;
  }
  result = console_cmdloop((consoleobject *) console, args);
  Py_DECREF(args);
  Py_DECREF(console);
  return result;
}

static PyMethodDef module_methods[] = {
  { CONSOLE_NAME, module_console, METH_NOARGS, console_doc },
  { NULL }
};

static void import_modules(void);

#ifndef PyMODINIT_FUNC
#define PyMODINIT_FUNC DL_EXPORT(void)
#endif

PyMODINIT_FUNC MODULE_INITFUNC(void) {
  PyObject *import, *class, *item, *module;
  
  if (PyType_Ready(&Parser_Type) < 0) return;

  /* Setup the console type's base classes */
  import = PyImport_ImportModule("cmd");
  if (import == NULL) return;
  class = PyObject_GetAttrString(import, "Cmd");
  Py_DECREF(import);
  if (class == NULL) return;
  Console_Type.tp_base = &PyBaseObject_Type;
  Console_Type.tp_bases = Py_BuildValue("(ON)", class, &PyBaseObject_Type);
  if (Console_Type.tp_bases == NULL) return;
  if (PyType_Ready(&Console_Type) < 0) return;

  item = PyString_FromString(PARSER_NAME "> ");
  if (PyDict_SetItemString(Console_Type.tp_dict, "prompt", item) < 0) return;
  Py_DECREF(item);

  module = Py_InitModule(PARSER_NAME "c", module_methods);
  if (module == NULL) return;
  
  Py_INCREF(&Parser_Type);
  PyModule_AddObject(module, "new", (PyObject *) &Parser_Type);
  Py_INCREF(&Parser_Type);
  PyModule_AddObject(module, PARSER_NAME, (PyObject *) &Parser_Type);

  /* import the modules required for action routines */
  import_modules();
}

static PyObject *import_from(char *modulename, char *fromname) {
  PyObject *fromlist, *name, *module;

  fromlist = PyTuple_New(1);
  if (fromlist == NULL) return NULL;

  name = PyString_FromString(fromname);
  if (name == NULL) {
    Py_DECREF(fromlist);
    return NULL;
  }
  Py_INCREF(name);
  PyTuple_SET_ITEM(fromlist, 0, name);

  module = PyImport_ImportModuleEx(modulename, NULL, NULL, fromlist);
  Py_DECREF(fromlist);
  if (module == NULL) {
    Py_DECREF(name);
    return NULL;
  }

  fromlist = PyObject_GetAttr(module, name);
  Py_DECREF(module);
  Py_DECREF(name);
  return fromlist;
}

static void import_modules(void) {
  /* from SPARQLParser import IRIRef */
  IRIRef = import_from("SPARQLParser", "IRIRef");
  if (IRIRef == NULL) return;

  /* from SPARQLParser import Bindings */
  Bindings = import_from("SPARQLParser", "Bindings");
  if (Bindings == NULL) return;

  /* from SPARQLParser import Query */
  Query = import_from("SPARQLParser", "Query");
  if (Query == NULL) return;

  /* from SPARQLParser import QName */
  QName = import_from("SPARQLParser", "QName");
  if (QName == NULL) return;

  /* from SPARQLParser import GraphPattern */
  GraphPattern = import_from("SPARQLParser", "GraphPattern");
  if (GraphPattern == NULL) return;

  /* from SPARQLParser import FunctionLibrary */
  FunctionLibrary = import_from("SPARQLParser", "FunctionLibrary");
  if (FunctionLibrary == NULL) return;

  /* from SPARQLParser import Operators */
  Operators = import_from("SPARQLParser", "Operators");
  if (Operators == NULL) return;

  /* from SPARQLParser import Triples */
  Triples = import_from("SPARQLParser", "Triples");
  if (Triples == NULL) return;

  /* from SPARQLParser import Resource */
  Resource = import_from("SPARQLParser", "Resource");
  if (Resource == NULL) return;

  /* from SPARQLParser import Filter */
  Filter = import_from("SPARQLParser", "Filter");
  if (Filter == NULL) return;

  /* from SPARQLParser import Util */
  Util = import_from("SPARQLParser", "Util");
  if (Util == NULL) return;

  /* from SPARQLParser import Expression */
  Expression = import_from("SPARQLParser", "Expression");
  if (Expression == NULL) return;

  /* from SPARQLParser import BooleanOperators */
  BooleanOperators = import_from("SPARQLParser", "BooleanOperators");
  if (BooleanOperators == NULL) return;

  /* from SPARQLParser import SolutionModifier */
  SolutionModifier = import_from("SPARQLParser", "SolutionModifier");
  if (SolutionModifier == NULL) return;

  /* import rdflib */
  rdflib = PyImport_ImportModule("rdflib");
  if (rdflib == NULL) return;

  /* from rdflib import RDF */
  RDF = import_from("rdflib", "RDF");
  if (RDF == NULL) return;

}
